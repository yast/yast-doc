<?xml version="1.0"?>
<!DOCTYPE article PUBLIC
  "-//OASIS//DTD DocBook XML V4.3//EN"
  "http://www.oasis-open.org/docbook/xml/4.3/docbookx.dtd"
[
    <!ENTITY version "0.02">

    <!-- A testing url to fake symbolic links. It should be changed to an empty string in production -->
    <!ENTITY base-url-path "">
    <!-- Relative or absolute url where all sources (examples) are stored -->
    <!ENTITY sources-base-url-path "sources/">
    <!-- Relative url where clean ycp sources are stored -->
    <!ENTITY t1-clean-sources "clean-ycp/">

    <!-- List of links to the source files (relative to the 'sources-base-url-path') -->
    <!ENTITY t1-href-sshd-starting-version "sshd-starting-version.tgz">
    <!ENTITY t1-href-sshd-continue-version "sshd-continue-version.tgz">
    <!ENTITY t1-href-sshd-final-version "sshd-final-version.tgz">
]>

<!--

  General Rules:
  ==============
    Particular Tutorials:  <chapter>...</chapter>
    Authors in chapter:    <chapterinfo><author><firstname>John</firstname><surname>Fish</surname></author></chapterinfo>
    First Class Sections:  <section id="xyz">...</section>
    Other Class Sections:  <section>...</section>
    Titles:                <title>First Letter Upper-Cased</title>
    Section Abstracts:     <abstract>...Abstract text...</abstract>
    Outer Links:           <ulink url="../where">Link Text</ulink>
    Internal Links:        <link linkend="linked_section_id">Link Text</link>
    Emphasization:         <emphasis>Phrase</emphasis>
    Commands:              <command>command</command>
    Commented Commands:    <screen>y2tool create-yast3</screen>
    Source Code:           <programlisting>a = 1;</programlisting>
    Lists:                 <itemizedlist><listitem>...</listitem></itemizedlist>
    Files and Directories: <filename>/usr/share/...</filename>
    SCR Agent Paths:       <filename>.agent.path</filename>

//-->

<book class="whitepaper" lang="en">
 <bookinfo>
 </bookinfo>

 <title>YaST Tutorials</title>
 <abstract>
  <para>These tutorials can help you to learn to develop your own YaST modules
   from scratch as quickly as possible. For more examples of YaST, see the
   <ulink url="file:///usr/share/YaST2/"><filename>/usr/share/YaST2/</filename></ulink>
   directory.</para>
 </abstract>
 
 <chapter id="general">
  <chapterinfo>
   <author>
    <firstname>Lukas</firstname>
    <surname>Ocilka</surname>
    <contrib>Chapter in general.</contrib>
   </author>
   <author>
    <firstname>Klara</firstname>
    <surname>Cihlarova</surname>
    <contrib>Chapter structural correctness, logic checks, ideas and enhancements.</contrib>
   </author>
  </chapterinfo>
  <title>YaST Development in General</title>
  <sect1 id="before_devel">
   <title>Before You Start Development</title>
   
   <para>
    Almost every YaST development needs a standard <emphasis>development
     environment</emphasis> with development tools. A developer should
    understand the terms used and know the YaST
    directory structure.</para>
   
   <sect2 id="before_devel_env">
    <title>Development Environment</title>
    <para>
     YaST module development is automated in many steps by a number of helper
     tools.  However, if you want to take advantage of it, you must install
     some additional packages.
    </para> 
    <para>
     Here is the full list of packages needed in alphabetical order:
     <emphasis><xi:include href="tutorial-includes/needed-packages.txt"
       parse="text"
       xmlns:xi="http://www.w3.org/2003/XInclude"/></emphasis>
    </para>  
   </sect2>

   <sect2 id="before_devel_terms">
    <title>Terminology</title>
     <!-- FIXME rwalter: if you have variablelist,
      you might want to use it here. -->
    <itemizedlist>
     <listitem>
      <para><emphasis>YaST Module</emphasis>&mdash;In a general view, a YaST
       module is a stand-alone tool for some functionality, such as the
       configuration tool for 
       an NFS server, user manager, or system monitoring tool.</para>
     </listitem>
     
     <listitem>
      <para><emphasis>Project</emphasis>&mdash;A project is a general concept
       for any YaST module.</para>
     </listitem>
     
     <listitem>
      <para><emphasis>YCP Module</emphasis>&mdash;Set of functionality inside
       a library written in the <emphasis>YCP</emphasis> language. It can have
       several 
       global or local functions and variables. A YaST module can use several
       YCP modules. A YCP module itself can also use other modules.</para>
     </listitem>
     
     <listitem>
      <para><emphasis>Perl Module</emphasis>&mdash;The same as a
       YCP module, but written in Perl.</para>
     </listitem>
     
     <listitem>
      <!-- FIXME: explain what SCR Agent really is -->
      <para><emphasis>SCR Agent</emphasis>&mdash;They are the only way to read
       and write a configuration or execute system commands. Developer mustn't
       touch the system by any other way. SCR Agents are very small programs 
       written in <emphasis>C</emphasis>, <emphasis>Bash</emphasis>, or
       <emphasis>Perl</emphasis> or written as scripts using the
       unified <emphasis>Ini-Agent</emphasis> or <emphasis>Any-Agent</emphasis>
       interface. YaST uses the unified <emphasis>SCR</emphasis> YCP module for
       accessing these agents.</para> 
     </listitem>
     
     <listitem>

      <para>
       <emphasis>Helper Tool</emphasis>&mdash;A script or binary that has some
       functionality for helping a developer achieve fast results by calling
       many annoying and repetitive commands on its own.</para> 
     </listitem>
    </itemizedlist>
    
   </sect2>

   <sect2 id="before_devel_dirstr">
    <title>YaST Directory Structure</title>
    <para>
     The directions in this tutorial touch several directories on the
     system. Here is the list of directories 
     where you can find files or directories related to YaST:</para>
    <screen>
/usr/lib/YaST2/                 -- helpers, libraries, and SCR agents
/usr/share/applications/YaST2/* -- .desktop files of YaST modules
/usr/share/YaST2/               -- base directory of YaST scripts, clients, and modules
/usr/share/doc/packages/yast2*  -- documentation for particular YaST packages
/var/lib/YaST2/                 -- variable data directory
/var/log/YaST2/                 -- logging directory with automatically rotated logs
</screen>
   </sect2>
  </sect1>
 </chapter>

 <chapter id="t1">
  <chapterinfo>
   <author>
    <firstname>Lukas</firstname>
    <surname>Ocilka</surname>
    <contrib>Tutorial in general, example source code, and screenshots.</contrib>
   </author>
   <author>
    <firstname>Stanislav</firstname>
    <surname>Visnovsky</surname>
    <contrib>Tutorial structure, correctness, and ideas.</contrib>
   </author>
   <author>
    <firstname>Klara</firstname>
    <surname>Cihlarova</surname>
    <contrib>Tutorial structural correctness, logical checks, ideas, and enhancements.</contrib>
   </author>
  </chapterinfo>
  
  <title>Tutorial 1&mdash;Simple YaST Module</title>
  <abstract>

   <para>
    This tutorial shows how to create your own YaST Module as simply as
    possible.  It is supposed to be a basic tutorial for a broad, but not deep,
    overview of developing a new YaST module in YCP.  It contains links where
    you can find more detailed information for the particular topic.</para>  

   <!-- FIXME: Create tutorial about a Perl support -->
  </abstract>

  <sect1 id="t1_best_practices">
   <title>Best Practices</title>
   <para>
    Before starting the development of a YaST module, think
    about the answers for these questions:
   </para>
   <itemizedlist>
    <listitem><para>What do you expect from this YaST module?</para></listitem>
    <listitem><para>What do you want to configure and how?</para></listitem>
    <listitem><para>Is YaST suitable for that?</para></listitem>
   </itemizedlist>
   <para>
    Understanding the service configuration or application used is essential.
    It avoids future problems with modifications of user interface, API, or
    internal data structures.
   </para>
  </sect1>

  <sect1 id="t1_spec">
   <title>What the Module Should Really Do?</title>
   
   <para>
    Project specification is a very important step in module development. The
    simple example shows how the project specification could be written.
   </para>
   
   <sect2 id="t1_spec_generalspec">
    <title>General Project Specifications and Terms</title>
    <para>Project specification is a very important part of every YaST
     Module. It shows whether it is worth the effort to develop such a YaST
     Module. It could also an insolvable problem before development starts or
     help find the best way to go in development.
    </para>

    <para>YaST, in general, is divided into several layers. Some of them can
     run on different computers:
    </para>

    <mediaobject>
     <imageobject>
      <imagedata fileref="screenshots/sshd/t1-yast-overview.png" format="PNG"/>
     </imageobject>
    </mediaobject>

    <itemizedlist>
     <listitem>
      <!-- FIXME rwalter: again, consider a variablelist -->
      <para>User Interface&mdash;A Graphical or textual user
       interface.</para>
     </listitem>

     <listitem>
      <para>UI Handling&mdash;Handles all user's events, dialogs and
       dialog workflow.</para>
     </listitem>

     <listitem>
      <para>Business Logic&mdash;Provides the global functional API and global
       variables (functional interface is the prefered one). Takes care about
       internal data handling and structure and access to SCR agents.</para>
     </listitem>

     <listitem>
      <para><ulink url="&base-url-path;../scr/index.html">System
      Agents</ulink>&mdash;Small programs for accessing the system files,
      databases, system commands, etc. They are called <emphasis>SCR
      agents</emphasis>.</para>
     </listitem>
    </itemizedlist>
    
    <para>It is quite common for bigger projects to have functions divided into
     several modules that can be written in YCP or Perl.
    </para>
   </sect2>
   
   <sect2 id="t1_spec_example">
    <title>Tutorial Example</title>
    
    <para>
     This example prepares to develop a YaST module for configuration of the
     SSH daemon.  Its configuration is stored in the
     <filename>/etc/ssh/sshd_config</filename> file.
    </para>

    <sect3 id="t1_spec_gpd">
     <title>General Project Definition</title>

     <important>
      <para>Keep in mind that this is only an example, not
       a real expert configuration tool. Features have been selected
       to keep the project extremely simple.</para>
     </important>
     
     <para>Chosen areas of configuration are:</para>
     <itemizedlist>
      <listitem><para>Server behavior with the options
	<emphasis>Port</emphasis>, 
	<emphasis>AllowTcpForwarding</emphasis>,
	<emphasis>X11Forwarding</emphasis>,  and
	<emphasis>Compression</emphasis></para></listitem>
      <listitem><para>Login settings with the options
	<emphasis>PrintMotd</emphasis> and 
	<emphasis>PermitRootLogin</emphasis></para></listitem>
      <listitem><para>Login features with the options
	<emphasis>MaxAuthTries</emphasis>, 
	<emphasis>PasswordAuthentication</emphasis>,
	<emphasis>RSAAuthentication</emphasis> 
	and <emphasis>PubkeyAuthentication</emphasis></para></listitem>
     </itemizedlist>
    </sect3>
    
    <sect3 id="t1_spec_uidw">
     <title>UI Dialog Workflow</title>

     <para>
      This module will use only two dialogs arranged in a
      <emphasis>wizard</emphasis> 
      sequence. Both dialogs will be based on the typical YaST dialog with a
      <guimenu>Back</guimenu>, 
      <guimenu>Abort</guimenu>, and <guimenu>Next</guimenu> buttons and the
      help text in the frame on the left side of the dialog. These dialogs will
      be surrounded by 
      <emphasis>Read</emphasis> dialog with a progress bar, where the current
      configuration is read, and <emphasis>Write</emphasis> dialog where a new
      configuration is written.</para>

     <para>This is the design of the proposed workflow:</para>
     <mediaobject>
      <imageobject>
       <imagedata fileref="screenshots/sshd/t1-workflow.png" format="PNG"/>
      </imageobject>
     </mediaobject>
     
     <para>This workflow also shows that user can abort the configuration on
      every screen by clicking 
      the <guimenu>Abort</guimenu> button. After this button is pressed, a
      pop-up dialog appears asking whether 
      to abort the configuration. When this is confirmed, the configuration is
      canceled and program is terminated without saving changes.</para>
    </sect3>

    <sect3 id="t1_spec_uid">
     <title>UI Dialogs</title>
     <para>The first dialog will contain a table of TCP ports used by the
      SSH daemon and its general features. The second one will contain all
      login settings.</para> 
     
     <para><emphasis>Drawing of the first dialog:</emphasis></para>
     <mediaobject>
      <imageobject>
       <imagedata fileref="screenshots/sshd/t1-dialog1-draw.png" format="PNG"/>
      </imageobject>
     </mediaobject>
     
     <para>
      The <guimenu>Back</guimenu> button will be disabled in the first dialog
      and the <guimenu>Next</guimenu> button will be replaced with the
      <guimenu>Accept</guimenu> button in the last dialog as it appears in
      every YaST module written strictly following the <ulink
       url="&base-url-path;../styleguide/">Program Text Style Guide</ulink>.
     </para>
     
     <para><emphasis>Drawing of the second dialog:</emphasis></para>
     <mediaobject>
      <imageobject>
       <imagedata fileref="screenshots/sshd/t1-dialog2-draw.png" format="PNG"/>
      </imageobject>
     </mediaobject>
    </sect3>

   </sect2>

  </sect1>
  <!-- FIXME: Create tutorial about using Firewall (CWM and/or other functions) -->

  <sect1 id="t1_devel">
   <title>Starting Up</title>

   <para>The next step is to begin actual development.</para>

   <sect2 id="t1_devel_newfromscratch">
    <title>Creating a New YaST Module</title>

    <para>
     The fastest way to create a new YaST module is to use the powerful
     <command>y2tool</command> script that, among many other things, can
     generate the directory structure for a new module and fills it with
     standard project files from a template. This tool is a part of
     <literal>yast2-devtools</literal> package.</para>

    <para>To view all available options for <command>y2tool</command>,
    enter the command:</para>
    <para><command>/usr/bin/y2tool --help</command></para>
    
    <para>You should get something similar to this list</para>
    <screen>create-new-package   gettextdomains       pot-spellcheck  y2autoconf
create-spec          check_icons          rny2rnc         y2automake
devtools-migration   checkin-stable       showy2log       y2compile
for-proofread        check-textdomain     svnall          y2makeall
generateYCPWrappers  check_ycp            tagversion      y2makepot
get-lib              kill-leftover-stuff  version</screen>

    <para>We want to create a new YaST module (package), so the most suitable
     option seems to be the <option>create-new-package</option> option. To
     view all suboptions for it, enter the command</para>
     
    <para><command>/usr/bin/y2tool create-new-package</command></para>
    
    <para>This is what you should get</para>
    
    <screen>Usage:
   create-new-package [-dsv] &lt;skeleton&gt; &lt;name&gt; &lt;maintainer&gt; &lt;email&gt;

   -v   verbose
   -d   debug
   -s   list of available skeletons

   skeleton   - the one which should be used (config, trans, ...)
   name       - of the component. A package name will be constructed
                like yast2-skeleton-name
   maintainer - his name
   email      - maintainer's, of course :-)</screen>

    <para>This command will create a new standard configuration module called <emphasis>sshd</emphasis>
     with <emphasis>John The Fish</emphasis> as the author:</para>
    <para><command>/usr/bin/y2tool create-new-package -v config sshd "John The Fish" "john@thesmallfish.net"</command></para>

    <para>You will get this structure of directories:
    </para>
    <screen>sshd
     agents    - SCR Agents
     doc       - Auto-generated documentation
     package   - Special directory for building RPM package with a .changes file
     src       - Project source files
     testsuite - Project automatic testsuites</screen>

    <para id="t1_download_sshd_starting_version">
     You can download the just created package
     <ulink url="&base-url-path;&sources-base-url-path;&t1-href-sshd-starting-version;">here</ulink>.
    </para>
   </sect2>

   <sect2 id="t1_check_progr">
    <title>Checking the Progress</title>
    <para>We have just created a new <emphasis>YaST sshd</emphasis> configuration module but how to start
     and run this module? The answer is pretty easy...</para>
    
    <sect3 id="t1_bring_alive_install">
     <title>Installing Project on the System</title>
     
     <para>This is the way how to install the current state of the project into the system:</para>
     
     <orderedlist>
      <listitem>
       <para>Enter the directory with source files:
	<command>cd sshd</command></para>
      </listitem>
      
      <listitem>
       <para>Check whether needed packages are installed and call YaST scripts needed
	for creating Makefiles: <command>make -f Makefile.cvs</command></para>
      </listitem>
      
      <listitem>
       <para>Check syntax, comments of functions, create generated documentation,
	compile *.ycp modules into their binary form *.ybc: <command>make</command></para>
      </listitem>

      <listitem>
       <para>Install all into particular directories, you have to become 'root'
	for that: <command>sudo make install</command></para>
      </listitem>
     </orderedlist>

     <important>
      <para>If there are any problems, it drops out a warning or an error message. Missing
      development package must be installed, syntax error must be fixed.</para>
     </important>
     
     <para>Once you have installed it for the first time, you only need to call
      <command>sudo make install</command> if you do some changes in the source code.</para>
    </sect3>

    <sect3 id="t1_bring_alive_run">
     <title>Running the Application</title>
     <para>If there were no errors during the previous steps, you can simply run this command
      to open up your new YaST SSHD Configuration Tool:
     </para>
     <para><command>sudo /sbin/yast2 sshd</command></para>

     <para>or just</para>

     <para><command>/sbin/yast2 sshd</command></para>
     
     <para>After that, YaST opens up a <emphasis>Read</emphasis> dialog with
      a progress bar and after the configuration is read, it automatically
      switches to the <emphasis>Configuration</emphasis> dialog which looks
      like this one:</para>
     
     <mediaobject>
      <imageobject>
       <imagedata fileref="screenshots/sshd/t1-first-start.png" format="PNG"/>
      </imageobject>
     </mediaobject>
    </sect3>
    
    <sect3 id="t1_bring_alive_logs">
     <title>Watching YaST Logs</title>
     <note>
      <para>It is very useful to watch the log files while developing and
       testing any YaST module or its part. You can do it as
       <emphasis>root</emphasis> with this command in some terminal:</para>
      <para><command>/usr/bin/tail -F /var/log/YaST2/y2log</command></para>
     </note>
    </sect3>
   </sect2>
  </sect1>

  <sect1 id="t1_devel_files">
   <title>YaST Module Files</title>
   <para>We have shown how really easy is to create a new YaST module, how to
    install it and run. Now you should learn more about source files
    inside the project: what they are good for, what they contain and what they
    handle.</para>

   <sect2 id="t1_files_connect">
    <title>Project Files &amp; YaST Layers</title>
    <para>This picture shows the disposal of project files to the particular
     layers of YaST. This is how the new YaST modules is supposed to be divided
     into files and corresponds with <ulink
     url="&base-url-path;&sources-base-url-path;&t1-href-sshd-final-version;">final
     version</ulink>. For instance, the file <filename>sshd.scr</filename>
     doesn't exist in a newly-generated template.
    </para>
    <mediaobject>
     <imageobject>
      <imagedata fileref="screenshots/sshd/t1-yast-overview-files.png" format="PNG"/>
     </imageobject>
    </mediaobject>
   </sect2>

   <sect2 id="t1_bring_alive_workflow">
    <title>Internal Workflow Explanation</title>
    <para>This part is rather complex and
     not so important - you can skip it if you want. </para>
    <para>What is done between calling the <command>/sbin/yast2 sshd</command>
     command and opening the UI up?</para>

    <orderedlist>
     <listitem>
      <para>Script <filename>/sbin/yast2</filename> defines internal variables,
       such as <emphasis>LC_CTYPE</emphasis>. Then it checks whether you have
       <emphasis>Qt</emphasis> or <emphasis>ncurses</emphasis> available and
       calls the <filename>/usr/lib/YaST2/bin/y2base</filename> binary.</para>
     </listitem>

     <listitem>
      <para>Binary <filename>/usr/lib/YaST2/bin/y2base</filename> is called
       with "<emphasis>sshd qt</emphasis>" or "<emphasis>sshd
       ncurses</emphasis>" as two program arguments. The
       <emphasis>y2base</emphasis> checks whether there is any
       <filename>sshd.ycp</filename> client in the
       <filename>/usr/share/YaST2/clients/</filename> directory and executes
       it.</para>
     </listitem>

     <listitem>
      <para>The <filename>sshd.ycp</filename> imports some binary modules such
       as <emphasis>Progress</emphasis>, <emphasis>Report</emphasis> or
       <emphasis>CommandLine</emphasis>, defines the command line options and
       includes the <filename>wizards.ycp</filename> file.</para>
     </listitem>

     <listitem>
      <para>The <filename>wizards.ycp</filename> file includes the
       <filename>dialogs.ycp</filename> file with defined dialogs and
       <filename>complex.ycp</filename> file with defined complex dialogs
       functions and then dialog sequences are defined.</para>
     </listitem>
     
     <listitem>
      <para>After closing the UI, the control is returned back to the
       <filename>sshd.ycp</filename> client which finishes the operation and
       exits.</para>
     </listitem>
    </orderedlist>
   </sect2>

   <sect2 id="t1_files_fam">
    <title>Familiarizing with Source Files</title>
    <para>You will find source files under the <filename>sshd/src/</filename>
     path. All those files are copied into the
     <filename>/usr/share/YaST2/</filename> path during the <command>make
     install</command> procedure. Let's clarify what is the purpose of these
     files on some simple examples. Files listed here are simplified, most of
     the content is replaced with a "<literal>...</literal>" mark. Important
     parts are emphasized. Files are sorted in a logical order.</para>

     <sect3 id="t1_files_fam_desktop">
      <title>File <filename>sshd.desktop</filename></title>
      <para>Application definitions for KDE, AutoYaST, YaST Control
       Center...</para>

      <xi:include href="tutorial-includes/sshd/t1-start-sshd.desktop"
       parse="xml" xmlns:xi="http://www.w3.org/2003/XInclude"/>
       
      <para>These settings are used by another applications than the YaST SSHD
       Configuration itself. They define the module behavior and
       identification. See the <ulink url="../tdg/desktop_files_yast.html">YaST
       Desktop Files</ulink> document for more details.</para>
     </sect3>

     <sect3 id="t1_files_sshdcl">
      <title>File <filename>sshd.ycp</filename></title>
      <para>A basic application <emphasis>client</emphasis> also with a command
       line interface definition. Command line support will be described
       in another tutorial.
       <!-- FIXME: create tutorial about a command line support -->
      </para>

      <para>Clients are stored under the
       <filename>/usr/share/YaST2/clients/</filename> path</para>

      <xi:include href="tutorial-includes/sshd/t1-start-sshd.ycp"
        parse="xml" xmlns:xi="http://www.w3.org/2003/XInclude"/>
	
      <para>This client is called by YaST binary, it includes the
       <filename>wizard.ycp</filename> file with defined sequences and calls
       the <literal>CommandLine::Run()</literal> wich, in our case, calls the
       <literal>SshdSequence()</literal> workflow from
       <filename>wizard.ycp</filename>.</para>

      <note>
       <para>We have also other clients
        <filename>&lt;module-name&gt;_auto.ycp</filename> for the AutoYaST and
	<filename>&lt;module-name&gt;_proposal.ycp</filename> for the
	installation proposal but they aren't needed for this tutorial.
       </para>
      </note>
     </sect3>    

     <sect3 id="t1_files_wizd">
      <title>File <filename>wizards.ycp</filename></title>
      <para>Contains dialogs sequence definitions that are used by
       clients.</para>

      <para>Wizards are stored under the
       <filename>/usr/share/YaST2/include/&lt;module-name&gt;/</filename>
       path.</para>

      <xi:include href="tutorial-includes/sshd/t1-start-wizards.ycp"
        parse="xml" xmlns:xi="http://www.w3.org/2003/XInclude"/>
      
      <para>First of all, <filename>complex.ycp</filename> and
       <filename>dialogs.ycp</filename> are included because they define
       dialogs that are used in dialog sequences.</para>
      <para>After that, aliases to these dialogs are defined in
       <literal>aliases</literal> map. Then sequences pointing to these
       aliases are defined in a <literal>sequence</literal> map.
       Sequence handlers defines the relationship between
       <emphasis>event</emphasis> returned by a dialog function and
       <emphasis>action</emphasis> called by sequencer.</para>
      <para>At the end, the <literal>SshdSequence()</literal> is called
       from the <filename>sshd.ycp</filename> client.</para>

      <important>
       <para>Never define the <emphasis>`back</emphasis> event, dialog wizard
	handles it by itself.</para>
      </important>
      
      <note>
       <para>Please, take note, that sequences can call another ones:
        <literal>SshdSequence()</literal> calls
	<literal>MainSequence()</literal> and that one calls
	<literal>AddSequence()</literal>.</para>

       <para>Sequence called from a client should contain
        <literal>Wizard::CreateDialog()</literal> and
	<literal>UI::CloseDialog()</literal> because user should see
	the UI as soon as possible. Additionally
	<literal>Wizard::CreateDialog()</literal> creates the classic
	<emphasis>Wizard</emphasis> window with help text on the left side,
	space for dialogs on the other one and <literal>Back</literal>,
	<literal>Abort</literal> and <literal>Next</literal> buttons.</para>

	<para>Screenshot of the Wizard window:</para>
        <mediaobject>
         <imageobject>
          <imagedata fileref="screenshots/sshd/t1-blind-wizard.png" format="PNG"/>
         </imageobject>
        </mediaobject>
      </note>
     </sect3>

     <sect3 id="t1_files_dlgs">
      <!-- FIXME: create tutorial for CWM usage -->
      <title>File <filename>dialogs.ycp</filename></title>
      <para>Dialogs definitions and their simple handling.</para>
      <para>Dialogs are stored under the
       <filename>/usr/share/YaST2/include/&lt;module-name&gt;/</filename>
       path</para>

      <xi:include href="tutorial-includes/sshd/t1-start-dialogs.ycp"
        parse="xml" xmlns:xi="http://www.w3.org/2003/XInclude"/>

      <para>This file defines two dialog functions
       <literal>Configure1Dialog()</literal> and
       <literal>Configure2Dialog()</literal>. These functions set the behavior
       by calling the <literal>Wizard::SetContentsButtons()</literal>
       function. We can use this advanced function because we have used the
       <literal>Wizard::CreateDialog()</literal> in the
       <filename>wizards.ycp</filename>.</para>
      <para>After the dialog is created there is a loop function that handles
       the user input.</para>
      <para>Help texts are included from the <filename>helps.ycp</filename> as
       the <literal>HELPS</literal> map.</para>
      
      <note>
       <para>Every string we want to mark for translation uses
        the <literal>_("...")</literal> notation. Every such string should
	have a comment for translators defined above. We use standard
        <emphasis>gettext</emphasis> style.</para>
       <para>Translations insist on defined
        <literal>textdomain</literal> inside the file.</para>
      </note>
     </sect3>

     <sect3 id="t1_files_cmpl">
      <title>File <filename>complex.ycp</filename></title>
      <para>YCP include which contains complex functions for dialogs
       handling.</para>

      <xi:include href="tutorial-includes/sshd/t1-start-complex.ycp"
       parse="xml" xmlns:xi="http://www.w3.org/2003/XInclude"/>

      <para>This file is very similar to the
       <filename>dialogs.ycp</filename> one but here should be more complex
       dialogs with handling.</para>
      <para>The most important is the <literal>ReadDialog()</literal>
       that calls the <literal>Sshd::Read()</literal>&mdash;a global function
       from the <literal>Sshd</literal> YCP module.</para>
      <para>Dialog functions defined in the file can be seen used in the
       <filename>wizards.ycp</filename> file in map of aliases.</para>
     </sect3>

     <sect3 id="t1_files_helps">
      <title>File <filename>helps.ycp</filename></title>
      <para>Help texts for every dialog.</para>

      <para>Helps are stored under the
       <filename>/usr/share/YaST2/include/&lt;module-name&gt;/</filename>
       path</para>

      <xi:include href="tutorial-includes/sshd/t1-start-helps.ycp" parse="xml"
	xmlns:xi="http://www.w3.org/2003/XInclude"/>

      <para>This file is included by the <filename>dialogs.ycp</filename>
       and <filename>complex.ycp</filename>. All texts are defined in the
       <literal>HELPS</literal> map.</para>
       
      <para>All help texts are written in <emphasis>HTML</emphasis> but they
       must follow the <ulink url="&base-url-path;../styleguide/">Text Style
       Guide</ulink>.</para>
      
      <note>
       <para>Please, take note, that help texts are divided into smaller chunks
        by logic parts. For translators, it's also easier to translate only
	a short string after you change something.</para>
       <!-- FIXME: replace with some inteligent text :) -->
      </note>

     </sect3>

     <sect3 id="t1_files_Sshd_ycp">
      <title>File <filename>Sshd.ycp</filename></title>
      <para>YCP module with global API that can be used from another modules
       or projects.</para>

      <para>All modules are stored under the
       <filename>/usr/share/YaST2/modules/</filename> path.</para>
       
      <!-- emphasized source file written in XML -->
      <xi:include href="tutorial-includes/sshd/t1-start-Sshd.ycp" parse="xml"
	xmlns:xi="http://www.w3.org/2003/XInclude"/>
	
      <para>The <literal>module</literal> keyword sets the module namespace.
       You can acces the global variables and function with the
       <literal>module_name::</literal> prefix (e.g.,
       <literal>Sshd::</literal> for <literal>Sshd</literal> module).</para>
       
      <para>Global <literal>Read</literal> and <literal>Write</literal>
       functions also define the <emphasis>Progress</emphasis> bar that is
       changed by calling <literal>Progress::NextStage()</literal>
       function.</para>
      
      <para><literal>Read</literal> and <literal>Write</literal> functions
       should always return a boolean whether they succeeded or
       failed.</para>

      <note>
       <para>Our project also contains the <filename>Sshd2.pm</filename> file
        that is a module written in a <emphasis>Perl</emphasis> language.
        Usage of a Perl module is is the same as usage of a YCP one but the
        internal syntax is different. Creating Perl modules will be explained
	in another tutorial.</para>
	<!-- FIXME: create short Perl-module tutorial including the
	 style of comments and documentation of functions -->
      </note>
     </sect3>

   </sect2>

  </sect1>

  <sect1 id="t1_devel2">
   <title>Cleaning Up Skeleton for the SSHD Configuration</title>
   <para>Now you know what can you find in every source file in your YaST module. This part will
    show you how to clean them up by removing functions and files unneeded for our module and a basic
    behavior and UI for SSHD Configuration will be set up.</para>
   
   <sect2 id="t1_devel2_msf">
    <title>Modifying Source Files</title>
    <para>This part will summarize functions and files removed from our YaST module
     <link linkend="t1_devel_newfromscratch">created using the y2tool</link> helper.</para>

    <sect3 id="t1_devel_msf_scr">
     <title>Changes in the <filename>src/</filename> directory:</title>
     
     <para id="t1_download_sshd_continue_version">
      You can download the changed source files
      <ulink url="&base-url-path;&sources-base-url-path;&t1-href-sshd-continue-version;">here</ulink>
      or you can download them one by one later in this section.
     </para>

     <sect4 id="t1_devel_msf_Sshdpm">
      <title>Files <filename>Sshd2.pm</filename> and <filename>Makefile.am</filename></title>
      <para>The file <filename>Sshd2.pm</filename>  has been completely removed
       from the project and also the appropriate record in the
       <filename>Makefile.am</filename> file should be changed to reflect on
       that change because installing files using the broken
       <filename>Makefile.am</filename> would lead into erroneous
       result.</para>
      <para>Original version:</para>
      <programlisting>module_DATA =                   \ 
       Sshd.ycp                \ 
       Sshd2.pm</programlisting>
      <para>New version:</para>
      <programlisting>module_DATA =                   \ 
       Sshd.ycp</programlisting>
     </sect4>

     <sect4 id="t1_devel_msf_Sshdycp">
      <title>File <filename>Sshd.ycp</filename></title>

      <note>
       <para>
        This configuration module will provide the basic <emphasis>functional
        interface</emphasis> with no global variables.</para>

       <para>The main reason for a functional interface is
       that you can simply control your configuration data flow. Global
       variables are more vulnerable to corruption by other modules.</para>
      </note> 

      <para>You had better download the changed file
       <filename>Sshd.ycp</filename> <ulink
       url="&base-url-path;&sources-base-url-path;&t1-clean-sources;Sshd.ycp">here</ulink></para>

      <para>Here you can see the list of changes in the original file:</para>

      <para>Cleaning the source code from unneeded functions:</para>
      <itemizedlist>
       <listitem>
	<para>Remove <literal>Modified()</literal> function (both definitions
	 <literal>global boolean Modified...</literal>).</para>
       </listitem>

       <listitem>
	<para>Remove <literal>AbortFunction()</literal> function.</para>
       </listitem>

       <listitem>
	<para>Remove <literal>Abort()</literal> function.</para>
       </listitem>

       <listitem>
	<para>Remove <literal>Export()</literal> function.</para>
       </listitem>

       <listitem>
	<para>Remove <literal>Summary()</literal> function.</para>
       </listitem>

       <listitem>
	<para>Remove <literal>Overview()</literal> function.</para>
       </listitem>

       <listitem>
	<para>Remove <literal>AutoPackages()</literal> function.</para>
       </listitem>

       <listitem>
	<para>Remove <literal>Import()</literal> function.</para>
       </listitem>
      </itemizedlist>

      <para>New and modified functionality:</para>
      <itemizedlist>
       <listitem>
        <para>Remove the <literal>global</literal> keyword from all definitions
	 of variables to make them local-only because we don't want anybody to
	 change our data internally but using the functions.</para>
	 <para>Original:</para>
	 <programlisting>global boolean modified = false;</programlisting>
	 <para>Changed:</para>
	 <programlisting>boolean modified = false;</programlisting>
       </listitem>

       <listitem>
        <para>Add this</para>
	<programlisting>import "Service";
import "Popup";</programlisting>
        <para>under other imports in the module. We are using these modules
	 later in the module.</para>
       </listitem>

       <listitem>
        <para>Add new variable definition</para>
	<programlisting>integer sl = 1000;</programlisting>
	<para>after the <literal>boolean modified...</literal>
	 definition. This variable is used for length definition of short
	 sleeps between read and write progress steps.</para>
       </listitem>

       <listitem>
	<para>Add new <literal>GetModified()</literal> function just after the
	 <literal>integer sl = 1000;</literal> definition:</para>
	 <programlisting>/**
 * Returns whether the configuration has been modified.
 */
global boolean GetModified() {
    return modified;
}</programlisting>
       </listitem>

       <listitem>
	<para>Add new <literal>SetModified()</literal> function after the
	 <literal>GetModified()</literal> one:</para>
	 <programlisting>/**
 * Sets that the configuration has been modified.
 */
global void SetModified() {
    modified = true;
}</programlisting>
       </listitem>

       <listitem>
	<para>Modify <literal>Abort()</literal> function:</para>
	<programlisting>/**
 * Returns a confirmation popup dialog whether user wants to really abort.
 */
global boolean Abort() {
    return Popup::ReallyAbort(GetModified());
}</programlisting>
       </listitem>
       
       <listitem>
        <para>Add new <literal>PollAbort()</literal> function after the
	 <literal>Abort()</literal> function:</para>
	 <programlisting>/**
 * Checks whether an Abort button has been pressed.
 * If so, calls function to confirm the abort call.
 *
 * @return boolean true if abort confirmed
 */
global boolean PollAbort() {
    if (UI::PollInput() == `abort)
	return Abort();

    return false;
}</programlisting>
       </listitem>

       <listitem>
	<para>Modify <literal>Read()</literal> function:</para>
	<para>Two useless progress steps were removed. Some texts were
	 changed, e.g., <literal>Sshd</literal> to
	 <literal>SSHD</literal>.</para>
        <programlisting>/**
 * Read all SSHD settings
 * @return true on success
 */
global boolean Read() {

    /* SSHD read dialog caption */
    string caption = _("Initializing SSHD Configuration");

    integer steps = 2;

    Progress::New( caption, " ", steps, [
    /* Progress stage 1/2 */
    _("Read current SSHD configuration"),
    /* Progress stage 2/2 */
    _("Read current SSHD state")
], [
    /* Progress step 1/2 */
    _("Reading current SSHD configuration..."),
    /* Progress step 2/2 */
    _("Reading current SSHD state..."),
    /* Progress finished */
    Message::Finished()
],
""
    );

    sleep(sl);

    if(PollAbort()) return false;
    Progress::NextStage();
    /* Error message */
    if(false) Report::Error(Message::CannotReadCurrentSettings());
    sleep(sl);

    if(PollAbort()) return false;
    Progress::NextStep();
    /* Error message */
    if(false) Report::Error(_("Cannot read current SSHD state."));
    sleep(sl);

    if(PollAbort()) return false;
    Progress::NextStage ();
    sleep(sl);

    modified = false;
    return true;
}</programlisting>
       </listitem>

       <listitem>
	<para>Modify <literal>Write()</literal> function:</para>
	<para>Some texts were changed, e.g., <literal>Sshd</literal> to
	 <literal>SSHD</literal>.
	 <literal>Message::SuSEConfigFailed()</literal> is replaced with
	 <literal>Message::CannotAdjustService("sshd")</literal>.</para>
	<programlisting>/**
 * Write all SSHD settings
 * @return true on success
 */
global boolean Write() {

    /* SSHD read dialog caption */
    string caption = _("Saving SSHD Configuration");

    integer steps = 2;
    
    Progress::New(caption, " ", steps, [
    /* Progress stage 1/2 */
    _("Write the SSHD settings"),
    /* Progress stage 2/2 */
    _("Adjust the SSHD service")
], [
    /* Progress step 1/2 */
    _("Writing the SSHD settings..."),
    /* Progress step 2/2 */
    _("Adjusting the SSHD service..."),
    Message::Finished()
],
""
    );

    sleep(sl);

    if(PollAbort()) return false;
    Progress::NextStage();
    /* Error message */
    if(false) Report::Error (_("Cannot write SSHD settings."));
    sleep(sl);

    if(PollAbort()) return false;
    Progress::NextStage ();
    /* Error message */
    if(false) Report::Error (Message::CannotAdjustService("sshd"));
    sleep(sl);

    Progress::NextStage ();
    sleep(sl);

    return true;
}</programlisting>
       </listitem>
      </itemizedlist>
     </sect4>

     <sect4 id="t1_devel_msf_cmpl">
      <title>File <filename>complex.ycp</filename></title>
      <para>You had better download the changed file
       <filename>complex.ycp</filename> <ulink
       url="&base-url-path;&sources-base-url-path;&t1-clean-sources;complex.ycp">here</ulink></para>

      <para>Here is the list of changes in the file:</para>

      <para>Removed unneeded functions:</para>
      <itemizedlist>
       <listitem>
	<para>Remove <literal>Modified()</literal> function.</para>
       </listitem>
       <listitem>
	<para>Remove <literal>ReallyAbort()</literal> function.</para>
       </listitem>
       <listitem>
	<para>Remove <literal>PollAbort()</literal> function.</para>
       </listitem>
       <listitem>
	<para>Remove <literal>SummaryDialog()</literal> function.</para>
       </listitem>
       <listitem>
	<para>Remove <literal>OverviewDialog()</literal> function.</para>
       </listitem>
      </itemizedlist>
     </sect4>

     <sect4 id="t1_devel_msf_dlgs">
      <title>File <filename>dialogs.ycp</filename></title>

      <para>You had better download the changed file
       <filename>dialogs.ycp</filename> <ulink
       url="&base-url-path;&sources-base-url-path;&t1-clean-sources;dialogs.ycp">here</ulink></para>

      <para>Here is the list of changes in the file:</para>

      <para>Removed unneeded functions:</para>
      <itemizedlist>
       <listitem>
	<para>Remove <literal>Configure1Dialog()</literal> function.</para>
       </listitem>
       <listitem>
	<para>Remove <literal>Configure2Dialog()</literal> function.</para>
       </listitem>
      </itemizedlist>

      <para>Added new functions:</para>
      <itemizedlist>
       <listitem>
	<para>Add new <literal>ServerConfigurationDialog()</literal>
	 function.</para>

	<para>This function creates a dialog using the Wizard module
	 and then handles the user input in the endless loop. After
	 the <literal>Abort</literal> or <literal>Next</literal> button
	 is pressed, handler skips outside the loop and returns the
	 <emphasis>ID</emphasis> of the pressed button as the function
	 result.</para>

	<xi:include href="tutorial-includes/sshd/t1-partial1-dialogs.ycp"
         parse="xml" xmlns:xi="http://www.w3.org/2003/XInclude"/>

        <para>This dialog defines the the table of TCP Ports connected with
         <emphasis>Add...</emphasis>, <emphasis>Edit...</emphasis> and
	 <emphasis>Delete</emphasis> buttons. <emphasis>Add...</emphasis> and
	 <emphasis>Edit...</emphasis> button labels are followed by dots
	 because pressing these buttons would open a new small pop-up dialog
	 on the top of the current one. <emphasis>Server Features</emphasis>
	 options are surrounded by a <emphasis>`Frame</emphasis> widget.</para>
	<para>&nbsp;</para>
       </listitem>

       <listitem>
	<para>Add new <literal>LoginSettingsDialog()</literal>
	 function.</para>

	<para>This function creates a dialog using the Wizard module
	 and then handles the user input in the endless loop. After
	 the <literal>Abort</literal>, <literal>Next</literal> or
	 <literal>Back</literal> button is pressed, handler skips outside
	 the loop and returns the <emphasis>ID</emphasis> of the pressed
	 button as the function result.</para>
	
	<xi:include href="tutorial-includes/sshd/t1-partial2-dialogs.ycp"
	 parse="xml" xmlns:xi="http://www.w3.org/2003/XInclude"/>

        <para>This simple dialog contains two frames of <emphasis>General
	 Login Settings</emphasis> and <emphasis>Authentication
	 Settings</emphasis> with check boxes.</para>
	<para>&nbsp;</para>
       </listitem>
      </itemizedlist>
     </sect4>

     <sect4 id="t1_devel_msf_hlps">
      <title>File <filename>helps.ycp</filename></title>

      <para>You had better download the changed file
       <filename>helps.ycp</filename> <ulink
       url="&base-url-path;&sources-base-url-path;&t1-clean-sources;helps.ycp">here</ulink></para>

      <para>Here is the list of changes in the file:</para>
      <itemizedlist>
       <listitem>
	<para>Remove helps for <literal>summary</literal>,
	 <literal>overview</literal>, <literal>c1</literal> and
	 <literal>c2</literal>.</para>
       </listitem>
       <listitem>
        <para>Add new helps for <literal>server_configuration</literal>
	 and <literal>login_settings</literal></para>
	 <programlisting>/* Server Configuration dialog help */
    "server_configuration" : _("&lt;p&gt;&lt;b&gt;&lt;big&gt;Server Configuration&lt;/big&gt;&lt;/b&gt;&lt;br&gt;
Configure SSHD here.&lt;br&gt;&lt;/p&gt;"),

    /* Login Settings dialog help */
    "login_settings" : _("&lt;p&gt;&lt;b&gt;&lt;big&gt;Login Settings&lt;/big&gt;&lt;/b&gt;&lt;br&gt;
Configure SSHD login settings here.&lt;br&gt;&lt;/p&gt;"),</programlisting>
       </listitem>
      </itemizedlist>

      <note>
       <para>Structure of helps is:</para>
       <programlisting>map HELPS = $[
       // TRANSLATORS: Comment for translators (this is a help text for...)
       "help_for" : _("Help text marked for translation..."),
       ];</programlisting>
      </note>
     </sect4>

     <sect4 id="t1_devel_msf_sshdcl">
      <title>File <filename>sshd.ycp</filename></title>

      <para>You had better download the changed file
       <filename>sshd.ycp</filename> <ulink
       url="&base-url-path;&sources-base-url-path;&t1-clean-sources;sshd.ycp">here</ulink></para>

      <para>Here is the list of changes in the file:</para>
      <itemizedlist>
       <listitem>
	<para>Remove a <emphasis>command line</emphasis> definition.</para>
       </listitem>
       <listitem>
	<para>Remove <emphasis>installation proposal</emphasis> support.</para>
       </listitem>
      </itemizedlist>
      
      <para>This client still runs the workflow via
       <literal>CommandLine</literal> module with an empty command line
       definition just to inform that the command line interface is not
       available for this module if anyone tries to run it.</para>
     </sect4>

     <sect4 id="t1_devel_msf_sshdauto">
      <title>File <filename>sshd_auto.ycp</filename></title>
      <para>This file has been completely removed from
       the package and also the appropriate record in the
       <filename>Makefile.am</filename> file.</para>
      <para>&nbsp;</para>
     </sect4>

     <sect4 id="t1_devel_msf_sshdpropo">
      <title>File <filename>sshd_proposal.ycp</filename></title>
      <para>This file has been completely removed from
       the package and also the appropriate record in the
       <filename>Makefile.am</filename> file.</para>

      <para><filename>Makefile.am</filename> file should be changed this way.</para>
      <para>Original version:</para>
      <programlisting>client_DATA =                   \
       sshd.ycp                \
       sshd_auto.ycp   \
       sshd_proposal.ycp</programlisting>
      <para>New version:</para>
      <programlisting>client_DATA =                   \
       sshd.ycp</programlisting>
      <para>&nbsp;</para>
     </sect4>

     <sect4 id="t1_devel_msf_wzrds">
      <title>File <filename>wizards.ycp</filename></title>

      <para>You had better download the changed file
       <filename>wizards.ycp</filename> <ulink
       url="&base-url-path;&sources-base-url-path;&t1-clean-sources;wizards.ycp">here</ulink></para>

      <para>Here is the list of changes in the file:</para>
      <itemizedlist>
       <listitem>
	<para>Remove <literal>AddSequence()</literal> function.</para>
       </listitem>
       <listitem>
	<para>Remove <literal>AutoSequence()</literal> function.</para>
       </listitem>
      </itemizedlist>
     </sect4>
    </sect3>

    <sect3 id="t1_devel_msf_testsuite">
     <title>Changes in the <filename>testsuite/</filename> directory</title>
     <para>Testsuites were designed for checking the global functionality,
      such as functions of modules, to keep them consistent. They can also help
      to find out when something else, used by your module, is suddenly
      changed.</para>
     <para>In this tutorial, all testsuites
      <filename>testsuite/tests/Sshd.*</filename> have been completely
      removed. Creating and running testsuites will be later described in
      another tutorial.</para>
     <!-- FIXME: create tutorial about creating and running testsuites -->
    </sect3>
   </sect2>

   <sect2 id="t1_checking_progress">
    <title>Checking the Progress</title>
    <para>We have worked hard to get this project where it is and now we would
     like to enjoy the current status by running the application.</para>

    <screen># Enter the basic directory of the project
cd sshd

# We have changed some Makefiles
make -f Makefile.cvs

# Check the syntax and compile YCP modules
make

# Install the project files to the system
sudo make install

# Run the application in Qt
sudo /sbin/yast2 sshd

# ... or run the application in ncurses
sudo /sbin/yast sshd</screen>
    <para>Now we can check it out. Dialogs are still not connected with the data,
     there are no pre-filled values and you still can't save the changed
     configuration, in spite of these facts, it is still a great success ;)!</para>

    <para>See the current status of your module:</para>
    <mediaobject>
     <imageobject>
      <imagedata fileref="screenshots/sshd/t1-progress-dialog1.png" format="PNG"/>
     </imageobject>
    </mediaobject>

    <mediaobject>
     <imageobject>
      <imagedata fileref="screenshots/sshd/t1-progress-dialog2.png" format="PNG"/>
     </imageobject>
    </mediaobject>
    
    <important>
     <para>After that, anytime you want to check the current status of changed source
      code, just run these commands:</para>
     <screen># Enter the directory with changed files
cd sshd/src/

# Compile and install files into the system
sudo make install

# Run the application
sudo /sbin/yast2 sshd</screen>
    </important>
   </sect2>
  </sect1>

  <sect1 id="t1_ui">
   <title>Creating User Interface</title>
   <para>Our project has already defined a User Interface in the
    <filename>scr/dialogs.ycp</filename> file. This section should explain some important parts
    of defining and handling the UI using some simple examples:</para>
   
   <sect2 id="t1_ui_dialogwizard">
    <title>Dialog Wizard</title>
    <para><emphasis>Wizard</emphasis> is a YCP module which do many annoying things
     on its own. It can do many things by a simple function call:</para>
    <itemizedlist>

     <listitem>
      <para>It automatically applies the current UI theme</para>
     </listitem>

     <listitem>
      <para><emphasis>Wizard::CreateDialog()</emphasis> - opens up a standardized
       dialog with correct width and height.</para>
     </listitem>

     <listitem>
      <para><emphasis>Wizard::SetContentsButtons(caption, dialog_content,
	dialog_help, back_button_label, next_button_label)</emphasis> - sets the
       dialog caption, content and buttons.</para>
     </listitem>

     <listitem>
      <para><emphasis>Wizard::DisableBackButton()</emphasis> - hides the
       <emphasis>Back</emphasis> button. It needs to be restored then.</para>
     </listitem>

     <listitem>
      <para><emphasis>Wizard::RestoreBackButton()</emphasis> - restores the hidden
       <emphasis>Back</emphasis> button</para>
     </listitem>

     <listitem>
      <para><emphasis>Wizard::SetNextButton(new_id, new_label)</emphasis> - changes
       the <emphasis>id</emphasis> and <emphasis>label</emphasis> of the
       <emphasis>Next</emphasis> button.</para>
     </listitem>

     <listitem>
      <para>...</para>
     </listitem>

    </itemizedlist>

    <para>All these functions are used in the <filename>dialogs.ycp</filename>
     for creating and handling the dialogs.</para>

    <para>See the <ulink url="&base-url-path;../modules/Wizard.html">Wizard</ulink> module
     documentation for the detailed information.
    </para>
   </sect2>
   
   <sect2 id="t1_ui_dialogcontent">
    <title>Dialog Content</title>
    <para>Dialogs contents are stored in variables with the <emphasis>term</emphasis>
     data-type.
    </para>
    <para>Fore more details about creating UI, widgets and layout see the
     <ulink url="&base-url-path;../tdg/Book-YCPUIlayout.html">YaST2 UI Layout and Events</ulink>
     documentation.</para>

    <important>
     <para>All widgets are case-sensitive.</para>
     <para>There can be no missing or extra comma separating widgets.</para>

     <programlisting>term contents = `VBox (
    `Left(`Label(_("SSHD TCP Ports"))) // &lt;--- missing a comma
    `Left(
	...
    )
);

term contents = `VBox (
    `Left(`Label(_("SSHD TCP Ports"))),
    `Left(
	...
    ), // &lt;--- an extra comma
);</programlisting>

     <para>The <literal>`Left</literal>, <literal>`Right</literal>,
      <literal>`Top</literal>, <literal>`Bottom</literal> and
      <literal>`Frame</literal> widgets accept only one term argument. If you
      want to put more widgets inside, surround them with the
      <literal>`VBox</literal> or <literal>`HBox</literal> widget:</para>

     <programlisting>`Frame (
        /* a dialog frame caption */
        _("Server Features"),
        `VBox (
            /* a check box */
            `Left(`CheckBox(`id("AllowTcpForwarding"), _("Allow &amp;TCP Forwarding"))),
            /* a check box */
            `Left(`CheckBox(`id("X11Forwarding"),      _("Allow &amp;X11 Forwarding"))),
            /* a check box */
            `Left(`CheckBox(`id("Compression"),        _("Allow &amp;Compression")))
	)
)</programlisting>
    </important>
   </sect2>
   
   <sect2 id="t1_ui_loophandling">
    <title>Standard Dialog Handling by a While-Loop</title>
    <para>Every pressed <literal>`PushButton</literal> widget returns its
     <emphasis>id</emphasis> on the user event query
     (<literal>UI::UserInput()</literal>). See
     <ulink url="&base-url-path;../tdg/AAA_All-Widgets_widget.html">AAA_All-Widgets</ulink>
     for more details about all possible general options for widgets.</para>

    <sect3 id="t1_ui_loophandling_slp">
     <title>Simple Loop Example</title>

     <para>This script creates a <literal>Wizard</literal> dialog with two
      push buttons and the
      <literal>Back</literal>-<literal>Abort</literal>-<literal>Next</literal>
      navigation at the bottom.</para>

     <para>If you press any of those two push buttons, the
      <literal>AnnounceKeyPress()</literal> function is called and reports the
      event by a pop-up window.</para>

     <para>When <literal>Back</literal> or
      <literal>Next</literal> button is pressed, it reports the event by
      a pop-up window and then the script finishes. When pressed the
      <literal>Abort</literal> button or when you try to close the window by
      your window manager's <literal>Close&nbsp;[x]</literal> button
      a confirmation of closing the script is required.</para>
     <programlisting>// loop_example.ycp
{
    <emphasis>/* --- importing needed modules --- */</emphasis>
    import "Wizard";
    import "Report";
    import "Label";
    import "Popup";
    <emphasis>/* --- importing needed modules --- */</emphasis>

    <emphasis>/* --- definition of functions --- */</emphasis>
    // dialog definition
    term <command>dialog_content</command> = `HBox (
	`PushButton(`id("pb_1"), "Button &amp;1"),
	`PushButton(`id("pb_2"), "Button &amp;2")
    );

    // function definition
    void AnnounceKeyPress (any key_pressed) {
	y2milestone("Pressed %1", key_pressed);
	// sformat replaces %1 with the value stored in key_pressed variable
	Report::Message(sformat("Button with id '<command>%1</command>' has been pressed.",
	    <command>key_pressed</command>)
	);
    }
    <emphasis>/* --- definition of functions --- */</emphasis>


    <emphasis>/* --- setting UI up --- */</emphasis>
    // Opening up a standard Wizard dialog
    <command>Wizard::CreateDialog();</command>
    Wizard::SetContentsButtons("Caption", <command>dialog_content</command>, "dialog help",
	Label::BackButton(), Label::NextButton());
    <emphasis>/* --- setting UI up --- */</emphasis>


    <emphasis>/* --- handling user input --- */</emphasis>
    any ret = nil;
    // starting the endless <emphasis>while (true) { do... }</emphasis> loop
    <command>while ("hell" != "frozen over") {</command>
	ret = UI::UserInput();
      
	// One of those dialog buttons have been pressed
	if (ret == "pb_1" || ret == "pb_2") {
	    AnnounceKeyPress(ret);

	// Back or Next navigation button have been pressed
	} else if (ret == <command>`back</command> || ret == <command>`next</command>) {
	    AnnounceKeyPress(ret);
	    // exits from the loop
	    <command>break;</command>

	// Confirmation question before closing the script
	} else if (ret == <command>`abort</command> || ret == <command>`cancel</command>) {
	    // exits from the loop when user confirms
	    if (Popup::ContinueCancel("Do you really want to abort?")) <command>break;</command>

	// unexpected return code
	} else {
	    Report::Error(sformat("Unexpected retcode %1", ret));
	}
    <command>}</command>
    <emphasis>/* --- handling user input --- */</emphasis>


    // Every opened dialog must be properly closed
    <command>UI::CloseDialog();</command>
}</programlisting>
    </sect3>
   </sect2>
   
  </sect1>

  <sect1 id="t1_scr">
   <title>Creating Access to the Configuration Data</title>
   <para>We have already set the UI up but we don't have any real configuration
    data. We will have some SCR Agent for reading and writing the
    <filename>/etc/ssh/sshd_config</filename> configuration file.</para>

   <sect2 id="t1_scr_scragent">
    <title>SCR Agent</title>
    
    <para>This section contains the general definition of any SCR Agent, way of
     looking for already written SCR Agent, technique how to create your own
     one and also the very important part about testing the SCR Agent.</para>

    <sect3 id="t1_scr_scragent_saig">
     <title>SCR Agents in General</title>
     <para>SCR is and abstraction layer. YaST never touches the system directly
      even if the functionality is written in Perl and such functionality
      exists.</para>

     <para>Every SCR Agent is a small program which transforms any service
      configuration, file attribute or whatever you can imagine into the YaST
      data-structure. They can be written in several languages such as
      <emphasis>C</emphasis>, <emphasis>Bash</emphasis>,
      <emphasis>Perl</emphasis> or <emphasis>Greenlandic</emphasis>.</para>

     <para>The most important functions of SCR Agent are
      <literal>Read()</literal> and <literal>Write()</literal> but not every
      SCR Agent needs to provide these functions. Additionaly, some SCR Agents
      have also the <literal>Execute()</literal> or <literal>Dir()</literal>
      function.</para>
    </sect3>

    <sect3 id="t1_scr_scragent_lfsa">
     <title>Looking for a SCR Agent</title>
     <para>The first thing, we should do, is to run through all already created
      <ulink url="&base-url-path;../scr/">SCR Agents</ulink> whether there is
      any agent we could use instead of creating a new one. After some time
      spent on browsing that documentation we could run across the universal
      <filename>.target</filename> agent which can
      also read and return a textual file as one string and might be also used
      in case when every other tries failed. Unfortunately this
      is not suitable for such yast-hacker you want to be. That's why we have
      to create our own <emphasis>SCR Agent</emphasis>.</para>
    </sect3>

    <sect3 id="t1_scr_creatingagent">
     <title>Creating Your Own SCR Agent</title>
     <para>Fortunately YaST has a configurable so-called <emphasis>IniAgent</emphasis>
      which is quite easy to use and sufficiently fulfills our needs. You can find its
      documentation here:
      <ulink url="file:///usr/share/doc/packages/yast2-core/agent-ini/ini.html">
      /usr/share/doc/packages/yast2-core/agent-ini/ini.html</ulink>
      (you need <emphasis>yast2-core-devel</emphasis> package installed).
      </para>

     <para>Our new SCR Agent should be able to:</para>
     <itemizedlist>
      <listitem>
       <para>Handle repeating options such as the <emphasis>Port</emphasis> definition</para>
      </listitem>
      <listitem>
       <para>Handle comments starting with the <emphasis>#</emphasis> string</para>
      </listitem>
     </itemizedlist>

     <para>This is the full definition of a <filename>.sshd</filename> SCR Agent which has
      the <emphasis>Read()</emphasis>, <emphasis>Write()</emphasis> and
      <emphasis>Dir()</emphasis> functions. It should be saved into the
      <filename>agents/sshd.scr</filename> file:</para>
     
     <xi:include href="tutorial-includes/sshd/t1-sshd.scr"
       parse="xml" xmlns:xi="http://www.w3.org/2003/XInclude"/>

     <para>The file <filename>agents/Makefile.am</filename> should be modified
      to have the <filename>sshd.scr</filename> added into the <emphasis>scrconf_DATA</emphasis>
      variable. This is the new version of <filename>agents/Makefile.am</filename>:</para>
     
     <programlisting># Makefile.am for sshd/agents

agent_SCRIPTS =

scrconf_DATA = sshd.scr

EXTRA_DIST = $(agent_SCRIPTS) $(scrconf_DATA)</programlisting>

     <para>Run command <command>sudo make install</command> in the <filename>agents</filename>
      directory to get it installed into the <filename>/usr/share/YaST2/scrconf/</filename>
      directory. Make sure, that the file has been copied there.</para>

     <para>Every SCR Agent should have documented its functionality in the file header.
      Examples for every function are also very important. See the agent configuration.</para>
     <para> For more information consult these agent's settings
      with the ini-agent documentation, please. This tutorial is not supposed to provide
      so complex information already described somewhere else.</para>
    </sect3>

    <sect3 id="t1_scr_testscr">
     <title>Testing the SCR Agent</title>
     <para>You can directly test the SCR Agent by running the <emphasis>y2base</emphasis>
      binary in the terminal with this command:
      <command>/usr/lib/YaST2/bin/y2base stdio scr</command>. Don't forget to watch
      your <filename>/var/log/YaST2/y2log</filename> file while testing.</para>

     <orderedlist>
      <listitem>
       <para>Start the y2base binary
	<command>/usr/lib/YaST2/bin/y2base stdio scr</command> returns:</para>
       <screen>([])</screen>
      </listitem>

      <listitem>
       <para>Getting already configured options with command
	<command>`Dir(.sshd)</command> returns:</para>
       <screen>(["Port", "PasswordAuthentication", "UsePAM", "X11Forwarding", "AcceptEnv", "AcceptEnv"])</screen>
      </listitem>

      <listitem>
       <para>Reading the UsePAM option with command
	<command>`Read(.sshd.UsePAM)</command> returns:</para>
       <screen>(["yes"])</screen>
      </listitem>

      <listitem>
       <para>Reading all the Port options with command
	<command>`Read(.sshd.Port)</command> returns:</para>
       <screen>(["22","33"])</screen>
      </listitem>
     </orderedlist>
     
     <para>Because this SCR Agent communicates using the standard I/O, you can replace the
      interactive call method with with the single command call using the <emphasis>pipe</emphasis>
      <command>echo '`Read(.sshd.UsePAM)' | /usr/lib/YaST2/bin/y2base stdio scr</command>
      which would return:</para>
     <screen>([])
(["yes"])</screen>
    </sect3>
    
   </sect2>
  </sect1>
  
  <sect1 id="t1_using_scr">
   <title>Using the Access to the Configuration Data</title>
   <para>We have created our own <filename>.sshd</filename> SCR Agent in the
    previous section. Let's see how we can use it in our project.</para>
   <para>In this section, we will modify the <filename>scr/Sshd.ycp</filename>
    YCP module.</para>

   <sect2 id="t1_using_scr_datamodel">
    <title>The Data Model</title>
    <para>As we could have seen during testing the <filename>.sshd</filename> SCR
     Agent, it returns a list of strings as values and variables are strings. So, let's
     decide to create an internal variable defined as
     <emphasis>map &lt;string, list&lt;string&gt;&gt;</emphasis>. Then we should know
     whether the <emphasis>sshd</emphasis> daemon was running during starting the
     configuration, because it this case we would have to restart it after changing the
     configuration file. Add this part just below the <emphasis>SetModified()</emphasis>
     function definition in the <filename>scr/Sshd.ycp</filename>:</para>
    <programlisting>/**
     * map of SSHD settings
     */
     map &lt;string, list&lt;string&gt; &gt; SETTINGS = $[];

     map &lt;string, list&lt;string&gt; &gt; DEFAULT_CONFIG = $[
     "Port"                      : ["22"],
     "AllowTcpForwarding"        : ["yes"],
     "X11Forwarding"             : ["no"],
     "Compression"               : ["yes"],
     "PrintMotd"                 : ["yes"],
     "PermitRootLogin"           : ["yes"],
     "IgnoreUserKnownHosts"      : ["no"],
     "MaxAuthTries"              : ["6"],
     "PasswordAuthentication"    : ["yes"],
     "RSAAuthentication"         : ["no"],
     "PubkeyAuthentication"      : ["yes"],
     ];</programlisting>
    <para>This part also defines the <emphasis>DEFAULT_CONFIG</emphasis> with
     default settings which we will use instead of the current one if the current
     one is not explicitly defined in the configuration file.</para>
   </sect2>
   
   <sect2 id="t1_using_scr_inmodule">
    <title>Reading and Writing the Configuration</title>
    
    <para>This part describes using the <emphasis>SCR Agent</emphasis> inside the
     YCP Module, reading and writing the current <emphasis>sshd</emphasis> service
     status and calling this functionality from the major <emphasis>Read()</emphasis>
     and <emphasis>Write()</emphasis> functions.</para>
    
    <sect3 id="t1_using_scr_inmodule_rws">
     <title>Reading and Writing the SCR</title>
     <para>Once we have the SCR Agent and the Data Model, we are about to create
      functions which will connect these two parts.</para>
     <para>Into the upper part of the <filename>src/Sshd.ycp</filename> add the import of
      the <emphasis>SCR</emphasis> module:</para>
     <screen>import "SCR";</screen>
     <para>Now we can use the <emphasis>SCR</emphasis> functions.</para>
     <para>Add this part below the <emphasis>PollAbort()</emphasis> function definition:</para>
     <programlisting>/**
 * Reads current sshd configuration
 */
boolean ReadSSHDSettings () {
    foreach (string key, (list &lt;string&gt;) <command>SCR::Dir(.sshd)</command>, {
	list &lt;string&gt; val = (list &lt;string&gt;) <command>SCR::Read(add(.sshd, key))</command>;
        if (val != nil) SETTINGS[key] = val;
    });
      
    y2milestone("SSHD configuration has been read: %1", SETTINGS);
    return true;
}

/**
 * Writes current sshd configuration
 */
boolean WriteSSHDSettings () {
    y2milestone("Writing SSHD configuration: %1", SETTINGS);

    foreach (string option_key, list &lt;string&gt; option_val, SETTINGS, {
	<command>SCR::Write(add(.sshd, option_key), option_val);</command>
    });
    <command>// This is very important
    // it flushes the cache, and stores the configuration on the disk
    SCR::Write(.sshd, nil);</command>

    return true;
}</programlisting>

     <para>The <emphasis>ReadSSHDSettings()</emphasis> function lists all already set
      options from the configuration file using the <emphasis>SCR::Dir()</emphasis> function,
      reads these options using the <emphasis>SCR::Read()</emphasis> function and if they
      have some value, stores them to the <emphasis>SETTINGS</emphasis> map.</para>
     <para>The <emphasis>WriteSSHDSettings()</emphasis> function writes all variables from the
      <emphasis>SETTINGS</emphasis> map to the agent's writing cache using the
      <emphasis>SCR::Write()</emphasis> function and then sends the <emphasis>nil</emphasis>
      to the same function to store this configuration to the configuration file.</para>
    </sect3>
    
    <sect3 id="t1_using_scr_inmodule_rwsss">
     <title>Reading and Writing the sshd Service Status</title>
     <para>Below the previous functions we will also add functions for reading the current
      status of the <emphasis>sshd</emphasis> service and for restarting if it is needed:</para>
     <programlisting>/**
 * Reads current sshd status
 */
boolean ReadSSHDService () {
    if (Service::Status("sshd") == 0) {
	sshd_is_running = true;
    } else {
	sshd_is_running = false;
    }

    y2milestone((sshd_is_running ? "SSH is running":"SSH is not running"));
  
    return true;
}

/**
 * Restarts the sshd when the daemon was running when starting the configuration
 */
boolean WriteSSHDService () {
    boolean all_ok = true;

    if (sshd_is_running) {
	y2milestone("Restarting sshd daemon");
	all_ok = Service::Restart("sshd");
    } else {
	y2milestone("Sshd is not running - leaving...");
    }
      
    return all_ok;
}</programlisting>
     <para>Here is the documentation for more information about the
      <ulink url="&base-url-path;../modules/Service.html">Service</ulink> module.</para>
    </sect3>
    
    <sect3 id="t1_using_scr_inmodule_grws">
     <title>General Read and Write Settings</title>
     <para>Then we have to change some lines in the general <emphasis>Read()</emphasis>
      and <emphasis>Write()</emphasis> functions to get the configuration read by starting
      the configuration and to get it written by finishing it.</para>
     <para>Here are the changes:</para>
     <itemizedlist>
      <listitem>
       <para>In the <emphasis>Read()</emphasis> function:</para>
       <screen>if(false) Report::Error(Message::CannotReadCurrentSettings());</screen>
       <para>replace with:</para>
       <screen>if(!ReadSSHDSettings()) Report::Error(Message::CannotReadCurrentSettings());</screen>
       <para>and</para>
       <screen>if(false) Report::Error(_("Cannot read current SSHD state."));</screen>
       <para>replace with:</para>
       <screen>if(!ReadSSHDService()) Report::Error(_("Cannot read current SSHD state."));</screen>
      </listitem>
      <listitem>
       <para>In the <emphasis>Write()</emphasis> function:</para>
       <screen>if(false) Report::Error (_("Cannot write SSHD settings."));</screen>
       <para>replace with:</para>
       <screen>if(!WriteSSHDSettings()) Report::Error (_("Cannot write SSHD settings."));</screen>
       <para>and</para>
       <screen>if(false) Report::Error (Message::CannotAdjustService("sshd"));</screen>
       <para>replace with:</para>
       <screen>if(!WriteSSHDService()) Report::Error (Message::CannotAdjustService("sshd"));</screen>
      </listitem>
     </itemizedlist>
    </sect3>
    
    <sect3 id="t1_using_scr_inmodule_sshdycp">
     <title>Complete Sshd.ycp file</title>
     <programlisting><xi:include href="tutorial-includes/sshd/t1-continue1-Sshd.ycp" parse="text"
       xmlns:xi="http://www.w3.org/2003/XInclude"/></programlisting>
    </sect3>
   </sect2>

   <sect2 id="t1_using_scr_syntaxcheck">
    <title>Checking the Syntax</title>
    <para>By now, we have finished implementing the <emphasis>Read()</emphasis> and
     <emphasis>Write()</emphasis> functions and we should check the syntax of the the
     source code. This can be done by running command:
     <command>/usr/bin/ycpc -E Sshd.ycp</command>. Eventual syntax errors must be fixed.</para>
   </sect2>

   <sect2 id="t1_using_scr_compilation">
    <title>YCP Module Compilation</title>
    <para>After you finish editing the <filename>src/Sshd.ycp</filename>, run
     <command>sudo make install</command> to get it compiled and installed into the system.</para>
    
    <para>Now you can check the progress as mentioned in the section
     <link linkend="t1_checking_progress">Checking the Progress</link> again.
     You should find the most important changes in the YaST log as mentioned in
     the section <link linkend="t1_bring_alive_logs">Watching YaST Logs</link>.</para>
   </sect2>

  </sect1>



  <sect1 id="t1_data_conn_ui">
   <title>Connecting the Configuration Data with the UI</title>
   <para>This part will show you how to connect the <emphasis>Sshd</emphasis> module data
    with the UI.
   </para>

   <sect2 id="t1_data_conn_ui_getsetconf">
    <title>Getting and Setting the Configuration Data</title>
    <para>Although our <emphasis>Sshd</emphasis> module can read and write the configuration
     and the UI is already able to make it read or written we don't have any functionality
     to get the configuration from the module or to set the new options or values. Let's add
     the last functions to the <filename>src/Sshd.ycp</filename>. Add these functions just above
     the <emphasis>Abort()</emphasis> function definition:</para>
    <programlisting>/**
 * Returns the SSHD Option as a list of strings.
 *
 * @param string option_key of the SSHD configuration
 * @return list &lt;string&gt; with option_values
 */
global list &lt;string&gt; GetSSHDOption (string option_key) {
    return SETTINGS[option_key]:DEFAULT_CONFIG[option_key]:[];
}

/**
 * Sets values for an option.
 *
 * @param string option_key with the SSHD configuration key
 * @param list &lt;string&gt; option_values with the SSHD configuration values
 */
global void SetSSHDOption (string option_key, list &lt;string&gt; option_vals) {
    SETTINGS[option_key] = option_vals;
}</programlisting>
    <para>Function <emphasis>GetSSHDOption()</emphasis> reads the <emphasis>SETTINGS</emphasis>
     map with the parameter <emphasis>option_key</emphasis> as the key of the map. If it is not
     defined, it tries to find the key in the <emphasis>DEFAULT_CONFIG</emphasis> map, otherwise
     it selects the <emphasis>[]</emphasis> which means the empty list. The first value found
     is returned by the function.</para>
    <para>Function <emphasis>SetSSHDOption()</emphasis> sets the list of strings
     <emphasis>option_vals</emphasis> as the value of the <emphasis>SETTINGS</emphasis> map
     identified by the <emphasis>option_key</emphasis> key.</para>
    
    <para>Do not forget to run the <command>sudo make install</command> command in the
     <filename>src/</filename> to compile and install the updated <emphasis>Sshd</emphasis>
     module</para>

    <para>This is the final content of <filename>Sshd.ycp</filename>:</para>
    <programlisting><xi:include href="tutorial-includes/sshd/t1-final-Sshd.ycp" parse="text"
      xmlns:xi="http://www.w3.org/2003/XInclude"/></programlisting>
   </sect2>

   <sect2 id="t1_data_conn_ui_handleconf">
    <title>Configuration Handling</title>
    <para>Almost all of this functionality is done in the <filename>scr/complex.ycp</filename>.
     Here you can see the final content of the file, it will be explained below:</para>
    
    <programlisting><xi:include href="tutorial-includes/sshd/t1-final-complex.ycp" parse="text"
      xmlns:xi="http://www.w3.org/2003/XInclude"/></programlisting>
    
    <para>Functionality contained in this file is explained in parts.</para>

    <sect3 id="t1_data_conn_ui_sfh">
     <title>Standard File Header</title>
     <programlisting>/**
 * File:	include/sshd/complex.ycp
 * Package:	Configuration of sshd
 * Summary:	Dialogs handling and definitions
 * Authors:	John The Fish &lt;john@thesmallfish.net&gt;
 *
 * $Id: complex.ycp 13891 2004-02-05 15:16:57Z jtf $
 */

{

textdomain "sshd";</programlisting>
     <para>This is here only for the completeness of the file. Nevertheles you can
      see at least the default style of the file header.</para>
    </sect3>

    <sect3 id="t1_data_conn_ui_imaif">
     <title>Imported Modules and Included Files</title>
     <programlisting>import "Label";
import "Popup";
import "Wizard";
import "Wizard_hw";
import "Sshd";
import "Confirm";
import "Report";

include "sshd/helps.ycp";</programlisting>
     <para>All <ulink url="&base-url-path;../modules/">YCP</ulink> or <ulink url="&base-url-path;../perlmodules/">Perl</ulink>
      modules have their documentation <ulink url="&base-url-path;../">here</ulink>. Take note of
      <emphasis>Sshd</emphasis> module being imported too.</para>
    </sect3>

    <sect3 id="t1_data_conn_ui_rwd">
     <title>Read and Write Dialogs</title>
     <programlisting>/**
 * Read settings dialog
 * @return `abort if aborted and `next otherwise
 */
symbol ReadDialog() {
    Wizard::RestoreHelp(HELPS["read"]:"");
    boolean ret = Sshd::Read();
    return ret ? `next : `abort;
}

/**
 * Write settings dialog
 * @return `abort if aborted and `next otherwise
 */
symbol WriteDialog() {
    Wizard::RestoreHelp(HELPS["write"]:"");
    boolean ret = Sshd::Write();
    return ret ? `next : `abort;
}</programlisting>
     <para>Standard <emphasis>ReadDialog()</emphasis> and
      <emphasis>WriteDialog()</emphasis> functions which are called from the
      <filename>src/wizards.ycp</filename> file. They call the appropriate functions of
      the <emphasis>Sshd</emphasis> module and return a <emphasis>symbol</emphasis> to
      the <emphasis>Sequencer</emphasis>.</para>
    </sect3>

    <sect3 id="t1_ui_init">
     <title>UI Data Initialization</title>
     <programlisting>/**
 * Initializes the table of ports
 */
void InitPortsTable () {
    list &lt;string&gt; ports = Sshd::GetSSHDOption("Port");

    if (ports != nil &amp;&amp; ports != []) {
	list &lt;term&gt; items = [];
	foreach (string port, ports, {
	    items = add (items, `item(`id(port), port));
	});

	// Redraw table of ports and enable modification buttons
	UI::ChangeWidget(`id("Port"), `Items, items);
	UI::ChangeWidget(`id("edit_port"), `Enabled, true);
	UI::ChangeWidget(`id("delete_port"), `Enabled, true);
    } else {
	// Redraw table of ports and disable modification buttons
	UI::ChangeWidget(`id("Port"), `Items, []);
	UI::ChangeWidget(`id("edit_port"), `Enabled, false);
	UI::ChangeWidget(`id("delete_port"), `Enabled, false);
    }
}

/**
 * Initializes the Server Configuration Dialog
 */
void InitServerConfigurationDialog() {
    InitPortsTable();

    foreach (string key, ["AllowTcpForwarding", "X11Forwarding", "Compression"], {
	UI::ChangeWidget(`id(key), `Value, (Sshd::GetSSHDOption(key) == ["yes"]));
    });
}

/**
 * Initializes the Login Settings Dialog
 */
void InitLoginSettingsDialog() {
    UI::ChangeWidget( `id("MaxAuthTries"), `ValidChars, "0123456789");
    list &lt;string&gt; MaxAuthTries = Sshd::GetSSHDOption("MaxAuthTries");
    UI::ChangeWidget(`id("MaxAuthTries"), `Value, MaxAuthTries[0]:"0");

    foreach (string key, ["PrintMotd", "PermitRootLogin",
	"PasswordAuthentication", "RSAAuthentication", "PubkeyAuthentication"], {
	    UI::ChangeWidget(`id(key), `Value, (Sshd::GetSSHDOption(key) == ["yes"]));
    });
}</programlisting>
     <para>Functions <emphasis>InitServerConfigurationDialog()</emphasis> and
      <emphasis>InitLoginSettingsDialog()</emphasis> initialize the appropriate dialogs
      and fill them up with the current data.</para>

     <para>Function <emphasis>InitLoginSettingsDialog()</emphasis> also sets the valid
      characters for the <emphasis>MaxAuthTries</emphasis> text entry to numbers only.</para>

     <para>Function <emphasis>InitPortsTable()</emphasis> is called from the
      <emphasis>InitServerConfigurationDialog()</emphasis>. It sets the list of
      currently configured used ports into the table and enables <emphasis>Edit</emphasis>
      and <emphasis>Delete</emphasis> buttons when some ports are configured. In the case
      of no ports configured disables those two buttons.</para>
    </sect3>

    <sect3 id="t1_ui_haeadb">
     <title>Handling Add, Edit and Delete Buttons</title>
     <programlisting>/**
 * Removes the port from list of current ports
 *
 * @param string port_number
 */
void DeletePort (string port) {
    Sshd::SetSSHDOption("Port", filter (
	string single_port, Sshd::GetSSHDOption("Port"), ``(single_port != port)
    ));
}

/**
 * Function handles the adding or editing port number.
 * When the current_port is not 'nil', the dialog will
 * allow to edit it.
 *
 * @param string current_port a port number to be edited or 'nil' when adding a new one
 */
void AddEditPortDialog (string current_port) {
    UI::OpenDialog(`opt(`decorated), `VBox(
	`MinWidth (30,
	    `HBox(
		`HSpacing(1),
		`Frame(
		    (current_port == nil ?
		    /* A popup dialog caption */
		    _("Add New Port")
		    :
		    /* A popup dialog caption */
		    _("Edit Current Port")),
		    /* A text entry */
		    `TextEntry(`id("port_number"), _("&amp;Port"), (current_port == nil ? "":current_port))
		),
		`HSpacing(1)
	    )
	),
	`VSpacing(1),
	`HBox(
	    `PushButton(`id(`ok), Label::OKButton()),
	    `HSpacing(1),
	    `PushButton(`id(`cancel), Label::CancelButton())
	)
    ));

    UI::ChangeWidget( `id("port_number"), `ValidChars, "0123456789");

    any ret = nil;
    while (true) {
	ret = UI::UserInput();
	if (ret == `ok) {
	    string new_port = (string) UI::QueryWidget(`id("port_number"), `Value);

	    if (new_port == "") {
		UI::SetFocus(`id("port_number"));
		Report::Error(_("Port number must not be empty."));
		continue;
	    }

	    Sshd::SetSSHDOption("Port", add (Sshd::GetSSHDOption("Port"), new_port));

	    if (current_port != nil) DeletePort(current_port);
	}

	break;
    }

    UI::CloseDialog();
}

/**
 * Function handles Add, Edit and Delete buttons
 *
 * @param any action from "add_port", "edit_port" or "delete_port"
 */
void HandleServerConfigurationDialog(any action) {
    string selected_port = (string) UI::QueryWidget(`id("Port"), `CurrentItem);

    // Adding a new port
    if (action == "add_port") {
	AddEditPortDialog(nil);
    // Editing current port
    } else if (action == "edit_port") {
	AddEditPortDialog(selected_port);
    // Deleting current port
    } else if (action == "delete_port") {
	if (Confirm::DeleteSelected()) DeletePort(selected_port);
    } else {
	y2error("Unknown action %1", action);
    }
      
    InitPortsTable();
}</programlisting>
     <para>The <emphasis>HandleServerConfigurationDialog()</emphasis> function
      handles the dialog events when any of <emphasis>Add</emphasis>,
      <emphasis>Edit</emphasis> or <emphasis>Delete</emphasis> buttons are
      pressed.</para>

     <itemizedlist>
      <listitem>
       <para><emphasis>Add</emphasis> button - Calls the
	<emphasis>AddEditPortDialog()</emphasis> function with <emphasis>nil</emphasis>
	as the parameter which means that no port is going to be edited, just added. This
	<emphasis>AddEditPortDialog()</emphasis> function opens up a small pop-up window
	containing the <emphasis>Add New Port</emphasis> text entry and
	<emphasis>OK</emphasis> and <emphasis>Cancel</emphasis> buttons. When the
	<emphasis>OK</emphasis> button is pressed, the new port is added into the list of
	current ports and the dialog is closed.</para>
      </listitem>
      <listitem>
       <para><emphasis>Edit</emphasis> button - Behaves almost the same but it calls the
	same function with the current port as the parameter. The text
	entry name in the pop-up dialog is <emphasis>Edit Current Port</emphasis> then
	and when the <emphasis>OK</emphasis> button is pressed, it also removes the
	old port.</para>
      </listitem>
      <listitem>
       <para><emphasis>Delete</emphasis> button - Calls the standardized
	<emphasis>Confirm::DeleteSelected()</emphasis> function which should be called
	every time user tries to remove such entry from a table. Then, if user confirms
	the deleting, it calls <emphasis>DeletePort()</emphasis> function which
	deletes the selected port.</para>
      </listitem>
     </itemizedlist>
    </sect3>

    <sect3 id="t1_ui_queryandstore">
     <title>Capturing the Current Configuration from UI</title>
     <programlisting>/**
 * Stores the current configuration from Server Configuration Dialog
 */
void StoreServerConfigurationDialog() {
    Sshd::SetModified();

    // Stores all boolean values and turns them to the "yes"/"no" notation
    foreach (string key, ["AllowTcpForwarding", "X11Forwarding", "Compression"], {
    Sshd::SetSSHDOption(
    key,
    [ (((boolean) UI::QueryWidget(`id(key), `Value) == true) ? "yes":"no") ]
    );
    });
    }

/**
 * Stores the current configuration from Login Settings  Dialog
 */
void StoreLoginSettingsDialog() {
    Sshd::SetModified();

    // Stores an integer value as a string
    Sshd::SetSSHDOption(
	"MaxAuthTries",
	[ (string) UI::QueryWidget(`id("MaxAuthTries"), `Value) ]
    );

    // Stores all boolean values and turns them to the "yes"/"no" notation
    foreach (string key, ["PrintMotd", "PermitRootLogin",
	"PasswordAuthentication", "RSAAuthentication", "PubkeyAuthentication"], {
	    Sshd::SetSSHDOption(
		key,
		[ (((boolean) UI::QueryWidget(`id(key), `Value) == true) ? "yes":"no") ]
	    );
    });
}</programlisting>
     <para>These functions get the UI widgets statuses and store them using the
      <emphasis>Sshd::SetSSHDOption()</emphasis> function. You can see how the
      <emphasis>boolean</emphasis> value of every check box is read and transformed to the
      <emphasis>yes/no</emphasis> notation which is used in the configuration file. All
      options have to be lists of strings.</para>
     <para>For reading the widget's status is used
      the <emphasis>UI::QueryWidget(`id(widget_id),&nbsp;`Value)</emphasis> function.</para>
     <para>Widget with id <emphasis>MaxAuthTries</emphasis> has not a
      <emphasis>boolean</emphasis> value so has its own call of
      <emphasis>UI::QueryWidget()</emphasis> and
      <emphasis>Sshd::SetSSHDOption()</emphasis>.</para>
    </sect3>

    <sect3 id="t1_ui_seof">
     <title>Standard End of File</title>
     <programlisting>}</programlisting>
     <para>This is the standard <emphasis>End of File</emphasis> left here just for the
      file completeness.</para>
    </sect3>
   </sect2>	
   
   <sect2 id="t1_data_conn_ui_conn">
    <title>Adding the Complex Connection into the Dialogs</title>
    <para>The module is nearly finished. The only thing we have to do is to add calling
     those <emphasis>Init*</emphasis>, <emphasis>Store*</emphasis> and
     <emphasis>Handle*</emphasis> functions into the dialogs definitions in the
     <filename>src/dialogs.ycp</filename> file.</para>

    <para>This is the final content, added functions are explained below:</para>
    <programlisting><xi:include href="tutorial-includes/sshd/t1-final-dialogs.ycp" parse="text"
      xmlns:xi="http://www.w3.org/2003/XInclude"/></programlisting>
    
    <sect3 id="t1_data_conn_ui_conn_scd">
     <title>Server Configuration Dialog</title>
     <para>Into the <emphasis>ServerConfigurationDialog()</emphasis> function
      between the <emphasis>Wizard::DisableBackButton();</emphasis> call and the
      <emphasis>while-loop</emphasis> add calling the dialog initialization
      function:</para>
     <programlisting>InitServerConfigurationDialog();</programlisting>

     <para>Into the <emphasis>ServerConfigurationDialog()</emphasis> function into the
      while-loop add the function call for storing configuration and for handling
      the <emphasis>Add</emphasis>, <emphasis>Edit</emphasis> and
      <emphasis>Delete</emphasis> buttons. The mentioned part of the while-loop should look
      like this one:</para>
     <programlisting>    while(true) {

    ret = UI::UserInput();
      
    /* abort? */
    if(ret == `abort) {
	if(Sshd::Abort()) break;
	else continue;
    /* next */
    } else if(ret == `next) {
	StoreServerConfigurationDialog();
	break;
    /* add, edit or delete */
    } else if (ret == "add_port" || ret == "edit_port" || ret == "delete_port") {
	HandleServerConfigurationDialog(ret);
    /* unknown */
    } else {
	y2error("unexpected retcode: %1", ret);
	continue;
    }
}</programlisting>
    </sect3>
    
    <sect3 id="t1_data_conn_ui_conn_lsd">
     <title>Login Settings Dialog</title>
     <para>Into the <emphasis>LoginSettingsDialog()</emphasis> function
      between the <emphasis>Wizard::SetNextButton(`next, Label::AcceptButton());</emphasis>
      call and the <emphasis>while-loop</emphasis> add calling the dialog initialization
      function:</para>
     <programlisting>InitLoginSettingsDialog();</programlisting>

     <para>Into the <emphasis>LoginSettingsDialog()</emphasis> function into the
      while-loop add the function call for storing configuration. It should look
      like this one:</para>
     <programlisting>    while(true) {

    ret = UI::UserInput();

    /* abort? */
    if(ret == `abort) {
	if(Sshd::Abort()) break;
	else continue;
    /* next */
    } else if(ret == `next) {
	StoreLoginSettingsDialog();
	break;
    } else if(ret == `back) {
	break;
    /* unknown */
    } else {
	y2error("unexpected retcode: %1", ret);
	continue;
    }
}</programlisting>
    </sect3>
   </sect2>

   <sect2 id="t1_data_conn_ui_inst">
    <title>Checking the Progress</title>
    <para>And that's it!</para>
    
    <important>
     <para>Do not forget to run command <command>sudo make install</command>
      after you finish editing the files in the <filename>src/</filename>
      directory to get the new versions installed.</para>
    </important>
    
    <para>Now you can run your new sshd module with command:
     <command>/sbin/yast2&nbsp;sshd</command>.</para>
   </sect2>

  </sect1>
  
  <!-- FIXME: Write something useful rather than this crap ;) -->
  <sect1 id="t1_use_and_celebrate">
   <title>Mission Completed</title>
   <para>We have completed the project development, now it's time to install
    and run the application and send it to the <ulink
    url="http://www.opensuse.org/">openSUSE</ulink> project.</para>

   <para id="t1_download_sshd_final_version">
    You can download the current sources <ulink
    url="&base-url-path;&sources-base-url-path;&t1-href-sshd-final-version;">here</ulink>.
   </para>

   <sect2 id="t1_tion">
    <title>Final Look &amp; Feel</title>
    <para>Let's enjoy the SSHD configuration module you have just done:</para>
    <mediaobject>
     <imageobject>
      <imagedata fileref="screenshots/sshd/t1-final-dialog1.png" format="PNG"/>
     </imageobject>
    </mediaobject>

    <mediaobject>
     <imageobject>
      <imagedata fileref="screenshots/sshd/t1-final-dialog2.png" format="PNG"/>
     </imageobject>
    </mediaobject>
    
    <para>Try to change some values and check them in the
     <filename>/etc/ssh/sshd_config</filename> configuration file.</para>
   </sect2>
  </sect1>

  <sect1 id="t1_conclusion">
   <title>Conclusion</title>
   <para>Congratulations! You have created you first own YaST module
    and you do understand all parts of it. You know...</para>
   <itemizedlist>
    <listitem>
     <para>how to create a <link linkend="t1_devel_newfromscratch">new
      project from scratch</link>.</para>
    </listitem>

    <listitem>
     <para>how to <link linkend="t1_ui_loophandling">handle user's
      events</link> from the UI.</para>
    </listitem>

    <listitem>
     <para>how to create your own <link linkend="t1_scr_creatingagent">SCR
      Agent</link>.</para>
    </listitem>

    <listitem>
     <para>how to <link linkend="t1_scr_testscr">run and test</link> the SCR
      Agent directly.</para>
    </listitem>

    <listitem>
     <para>how to <link linkend="t1_ui_init">initialize</link> the UI
      state.</para>
    </listitem>

    <listitem>
     <para>how to <link linkend="t1_ui_queryandstore">query and store</link>
      the UI state.</para>
    </listitem>

    <listitem>
     <para>what is supposed to be in each <link linkend="t1_devel_files">file
      of the project</link>.</para>
    </listitem>

    <listitem>
     <para>wow to use the SCR Agent <link linkend="t1_using_scr_inmodule">in a
      YCP Module</link>.</para>
    </listitem>

    <!-- FIXME: add yet another summary item -->

   </itemizedlist>

   <sect2 id="t1_conclusion_basis">
    <title>YaST Knowledge Summary</title>
    <para>When you known how to do this things, you might want to know where to
     find more information about YaST development and knowledge.</para>
    <para>The <ulink url="&base-url-path;../">YaST General
     Documentation</ulink> is a top-most level of all the centralized
     documentation. Here are some important links chosen from that
     documentation:</para>

    <itemizedlist>
     <listitem>
      <para><ulink url="&base-url-path;../faq.html">FAQ&mdash;Frequently Asked
       Question</ulink></para>
     </listitem>

     <listitem>
      <para><ulink url="&base-url-path;../tdg/id_ycp_data_types.html">YCP Data
       Types</ulink></para>
     </listitem>

     <listitem>
      <para><ulink url="&base-url-path;../tdg/id_ycp_operators.html">YCP
       Operators</ulink></para>
     </listitem>

     <listitem>
      <para><ulink url="&base-url-path;../tdg/id_ycp_progstruct.html">YCP
       Program Structure</ulink></para>
     </listitem>

     <listitem>
      <para><ulink url="&base-url-path;../tdg/id_modules.html">YCP
       Modules</ulink></para>
     </listitem>

     <listitem>
      <para><ulink url="&base-url-path;../tdg/yast2-logging.html">YaST
       Logging</ulink></para>
     </listitem>

     <listitem>
      <para><ulink url="&base-url-path;../tdg/ref_ui.html">UI functions and
       Widgets</ulink></para>
     </listitem>
     <!-- FIXME: more more more -->
    </itemizedlist>
   </sect2>
   
   <sect2 id="t1_conslusion_downloads">
    <title>Downloads</title>
    <para>Here are listed the source codes in particular stages of the module
     development:</para>

    <itemizedlist>
     <listitem>
      <para><ulink
       url="&base-url-path;&sources-base-url-path;&t1-href-sshd-starting-version;">Starting
       version</ulink>&mdash;just a newly created module with the y2tool. Link
       to the <link linkend="t1_download_sshd_starting_version">respective
       part</link> of the tutorial.</para>
     </listitem>

     <listitem>
      <para><ulink
       url="&base-url-path;&sources-base-url-path;&t1-href-sshd-continue-version;">Implemented
       UI</ulink>&mdash;after the UI is implemented and the dialog workflow is
       working. Link to the
       <link linkend="t1_download_sshd_continue_version">respective part</link>
       of the tutorial.</para>
     </listitem>

     <listitem>
      <para><ulink
       url="&base-url-path;&sources-base-url-path;&t1-href-sshd-final-version;">Final
       version</ulink>&mdash;when the module is completed. Link to the <link
       linkend="t1_download_sshd_final_version">respective part</link> of the
       tutorial.</para>
     </listitem>
    </itemizedlist>
   </sect2>

  </sect1>

  <sect1 id="t1_te_and_tu">
   <title>Testing and Tuning</title>
   <para>...not finished...</para>
   <!-- FIXME: there's nothing about testing and tuning! -->
  </sect1>
 </chapter>

</book>

 <!-- Keep this comment at the end of the file
 Local variables:
 mode: xml
 coding: utf-8
 sgml-indent-step: 1
 End:
 -->



