			    YaST2 Language Bindings
                           =========================

	     Using YaST2 with Programming Languages other than YCP
            -------------------------------------------------------

Proceedings of the YaST2 meeting 2003-10-30 in Nuernberg

Participants:

    kkaempf@suse.de
    msvec@suse.cz
    mvidner@suse.cz
    sh@suse.de
    visnov@suse.cz

Minutes:

    sh@suse.de


Motivation
==========

In order to lower the entry threshold and the learning curve on how to make
useful YaST2 extensions it is planned to add support for scripting languages
other than (YaST2 native) YCP to YaST2.

Reasons:

- Libraries written in other scripting languages could more easily be used for
  both YaST2 and other administration tools (e.g. web-based).

- There are many more developers who are fluent in scripting languages like
  Perl rather than YCP.

- The YaST2 team's resources to teach and support YCP newbies are limited.

- Third parties would no longer be required to use a SuSE proprietary scripting
  language (YCP) to make configuration modules for their special soft- or
  hardware.

- There are many (in-house) developers who don't have the first clue of what it
  is all about, yet flatly refuse getting in touch with YCP. Even though this
  is really irrational (get to know it first, blame it later if there are any
  reasons), it prevents them from contributing anything to YaST2.


Requirements
============

(Note: Priorities are not final yet)


(1) Language independence (Priority: 10 (highest))

    We don't want to support only Perl or only Python. We want language
    bindings that are independent of the 'foreign' language (called $FOREIGN
    from here on) - no calls specific to Perl, Python or anything else.



(2) Bi-directional (Prio: 5)

    We want to be able to use $FOREIGN from YCP and - if possible at all - to
    call YCP from $FOREIGN. Calling $FOREIGN from YCP is more important.


(3) Type control (Prio: 10)

    This is a lesson learned the hard way in all the years of programming
    YaST2: Variable and function types need to be tightly controlled - no more
    catch-all type info like type 'any'. The (YCP) interpreter is to catch all
    the programming errors that can be found - possibly at parse time, not only
    at run time: Large portions of (all kinds of) code typically are never
    executed because it is about handling weird errors that typically turn up
    only in the most pathological cases - out on the customer's machine, not
    under lab conditions here while we are developing. We want to find those
    bugs before we ship the product. We need all the tool support we can get
    for that. Thus we need a YCP interpreter and thus $FOREIGN language
    bindings that can report such bugs as early as possible.


(4) Transparency (Prio: 10)

    The application developer should not need to know what programming language
    anything he calls is written in. The call syntax needs to be independent of
    the target language. We want to be able to exchange modules without needing
    to change each call to it.


(5) Low runtime overhead (Prio: 7)

    Calling $FOREIGN should not be significantly more expensive than calling
    YCP. Converting data between $FOREIGN and YCP should be as optimized as
    possible.


(6) Nested name spaces (Prio: 10)

    It should be possible to nest name spaces. YCP currently supports one level
    of name spaces - the module a function or variable belongs to, e.g.
    "MyMod::func()". When multiple languages come into play, name space
    pollution will very soon become an issue. Multiple levels of name spaces
    should help alleviate that problem ("World::Solution::saveEarth()").


(7) Access to variables (Prio: 2)

    If technically possible, language bindings should support access to (global
    or module-level) variables in either direction - reading or assigning
    $FOREIGN variables from YCP or vice versa.


(8) Objects vs. packages - DROPPED

    It has been discussed if language bindings should support object instances
    rather than only package level function calls and variable access. The
    general conclusion was that this is currently not needed. Wrapper modoules
    can easily be written in $FOREIGN if $FOREIGN requires an instance of an
    object, should that become necessary.

    Otherwise YCP itself would need to be heavily expanded to support the
    concept of object handles or references or pointers.

    Java would be one example of a target language that would require having
    object references. Perl, Python, Tcl (to name just a few common scripting
    languages) can easily do without that.



Implementation Details
======================

(a collection of losely connected thoughts so far, the result of collective
brain storming)


(1) A $FOREIGN interpreter should be dynamically loaded on demand. We don't
    want the YaST2 core engine linked statically against all kinds of
    interpreters.

(2) Using $FOREIGN from YCP should be transparent to the caller. The standard
    YCP "import" statement is to be used for both YCP and $FOREIGN modules. The
    implementation of "import" has to decide if and when to load a module
    written in $FOREIGN rather than in YCP.

(3) There should be exactly one access path to each module, no matter what
    language it is written in. There will be no complicated search path rules
    that in daily practice tend to confuse application developers more than
    they help organze things.

    Examples:

	import "World::Solution::SaveEarth"
	loads /usr/share/YaST2/modules/World/Solution/SaveEarth.*

    SaveEarth.* in that path must be unique, otherwise an error is issued
    (trivial leftover stuff like editor backup files will silently be ignored -
    e.g., *~, *.bak, *.auto).

(4) One single instance of a $FOREIGN interpreter will be created per YaST2
    run: Modules written in $FOREIGN need to be able to store static or global
    data between invocations.

    Coding style: Modules that have a significant amount of data should provide
    a cleanup function to get rid of that data on demand. Otherwise leftover
    static of global data would accumulate, in effect creating memory leaks.

(5) As much type information as possible should be passed to the YaST2 runtime
    system (the YCP interpreter) - possibly at parse time, so type errors can
    be found even in code that is usually not covered by test cases.

    Perl bindings for examples could provide such type information in BEGIN{}
    blocks - they are executed at a very early stage (upon Perl::Parse()).

