<HTML>
<HEAD>
<TITLE>YaST2: Implementation: Interface: Internationalisation</TITLE>
</HEAD>
<BODY bgcolor=#ffffff>
<H1>YaST2: Implementation: Interface: Internationalisation</H1>

<h2>Character encoding</h2>

A good source about character encoding at the various standardization
efforts can be found at <A HREF="http://czyborra.com">czyborra.com</A>.
<br>
It looks like <b>UTF-8</b> is widely supported and the (by now) recommended
way to encoded non-latin charsets. Especially, UTF-8 is supported by GLIBC 2.x
and gnu gettext.
<br>
SuSE linux includes <tt>kbd-0.99</tt> to set console fonts, the linux console
driver understands <tt>ESC % 8</tt> (<tt>echo -e '\033%8'</tt>) to switch into
UTF-8 mode (use <tt>echo -e '\033%@'</tt> to switch back)

<p>
<h2>Fonts</h2>

Displaying foreign characters is a matter of available fonts and the
available display medium.<br>
On the console, the fonts below <tt>/usr/lib/kbd/consolefonts</tt> can be
used and installed with <tt>setfont</tt>. Fonts on X11 are another (currently
undocumented) issue.<br>
There are links at <A HREF="http://czyborra.com">czyborra.com</A> to
a console font, a better website is <A HREF="www.freetype.org">freetype.org</A>
with a lot of conversion tools.<p>
For a first implementation, we should concentrate on the currently (SuSE 6.2)
supported languages, which are listed on the <A HREF="http://www.suse.de/yast-int">
SuSE translation project</A> website.
<p>
<h2>Library</h2>
<b>gnu gettext</b> (or some similar implementation) should be used for the
user interface.<br>
This effectively separates text and its translations from program code. So we
can publish the text for translation by the community (as it's done now for yast-int) or hand it over to a
translator.
<p>
In the case of html (browser ui), the implementation might be
a cgi which runs on an intermediate host. This can load charsets (i.e. graphical
images representing characters) at runtime. Using gnu gettext inside the cgi
requires having all translations on the cgi server at runtime. This is bad.
<p>
<hr>
Only the module <i>specification</i> file has knowledge about its messages and possible translations.
<p>
The ui has knowledge about the user and his preferred language.
<p>
--> module and ui must talk to another about messages and translations.
<p>
The module must make no assumptions about the ui !
<p>
<h3>Preferred solution</h3>

The module is registered with the workflow manager (wfm). This registration
also includes the message base with all possible translations. So the wfm
has knowledge about the modules and the translations.
<p>
When the ui wants to use a module, it must ask the wfm to run the module.
This implies some sort of <i>login</i> of the ui to the wfm. Here the preferred
language can be set.<br> All messages are routed through the wfm which passes
the correct translation to the ui (preferrably UTF-8 coded). The gettext library
is used by the wfm, not by the ui.<p>
The distinction between translatable (i.e. informative descriptions) and
non-translatable text (i.e. filenames) must be done by the module. printf-style
output (embedding translatable text with placeholders for non-translatable text)
might not work (because printf ("%s", translatable_text) might be used).<p>
A better solution can be the <i>tagging</i> of output with tags like 'bold', 'italic',
'red', 'translatable', etc. This can easily be parsed and non-supported tags ('red' on b/w screen)
skipped.
<p><hr>
<SMALL>Last changed 16-7-1999 09:50, <A HREF="mailto:kskaem@suse.de">Klaus Kämpf</A></SMALL><BR>
<SMALL>Copyright &copy; by <A HREF="http://w3.suse.de">SuSE GmbH</A></SMALL>
</BODY>
</HTML>

