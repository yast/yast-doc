<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
 <META NAME="GENERATOR" CONTENT="SGML-Tools 1.0.9">
 <TITLE>The YaST2 Component Architecture: The Translator</TITLE>
 <LINK HREF="Y2Bible-10.html" REL=previous>
 <LINK HREF="Y2Bible.html#toc11" REL=contents>
</HEAD>
<BODY>
Next
<A HREF="Y2Bible-10.html">Previous</A>
<A HREF="Y2Bible.html#toc11">Contents</A>
<HR>
<H2><A NAME="s11">11. The Translator</A></H2>

<P>
<P>
<H2><A NAME="ss11.1">11.1 How the translator works</A>
</H2>

<P>
<P>The translator is a server component whose task is localization. It does not
contain a YCP interpreter. It merely analysis each YCP value it gets and
replaces any value of the type YCP locale with a localized string. YCP locales
have the ASCII syntax _("somestring"). Currently only strings can be
localized.
<P>In order to know which string should be inserted instead of the English one
that is contained in _("...") the translator has two global
variables: The current language and the current module name. For each language
and for each modulename it has a message catalogue located in
<P>
<BLOCKQUOTE><CODE>
<PRE>
/usr/lib/YaST2/locale/&lt;LANG&gt;/LC_MESSAGES/&lt;modulename&gt;.mo.
</PRE>
</CODE></BLOCKQUOTE>
<P>The message catalogues are created by gettext. It is important to have
separated message catalogues for separate modules. Otherwise it would be
impossible to update or replace single modules without touching the other
ones.
<P>In order to understand how the translator knows which language and which
module name is currently the right one I will explain, how the translator is
integrated into the Y2 base cell. In the chapter about the Y2 base cell I told
you, that each Y2 base cell consists of exactly two components: one server and
one client component. This is only true as long as no translation is
performed. If you specify the option -T or --translate as a generic server
option (right after the name of the server) a third component, the server
component 'translator', is being created.
<P>[ Hier muss ich mal in die Quellen schauen, wie das mit dem translated
server nochmal genau ablaeuft ].
<P>
<H2><A NAME="ss11.2">11.2 When Exactly Localization Occurs</A>
</H2>

<P>
<P>The most important constraint for the localization of Y2 modules is the fact,
that the module and the user interfaces run on different machines. On the
machine where the UI is running might be installed another version of Y2 or
may even be installed only the user interface and not a single module. Or it
might be another version of the same module with other translations. In other
words: The localized texts <I>must</I> be localized on that machine where
the module, i.e. the client component is running.
<P>A general implication of this is that a text that is sent to the UI must
either be localized or <I>all</I> possible translations must be sent at
once
<BLOCKQUOTE>Not mentioning a theoretical third possibility where the UI asks
the translator each time it wants to display a text for its translation.  As
both may be running on different sides of a slow network connection we ruled
this out.</BLOCKQUOTE>
. The translator uses the first variant since the second
one would create a large overhead
<BLOCKQUOTE>On SuSE Linux 6.4, the YaST2
installer and configurator comes with at least partialtranslations in 20
languages.</BLOCKQUOTE>
. When writing Y2 modules you have to keep this in
mind. Anything that is sent to the UI is getting once and forever localized by
the translator. Consider an example where a YCP module defines in the UI a
macro for displaying a typical "<I>Are you sure?</I>" question.
<P>
<BLOCKQUOTE><CODE>
<PRE>
{
    UI(''{
        define AreYouSure(string text) ''{
            OpenDialog(`VBox(`Label(text),
                `HBox(`PushButton(`id(`ok), _("&amp;Yes")),
                      `PushButton(_("&amp;No")))));
            boolean ok = UserInput() == `ok;
            CloseDialog();
            return ok;
        }
    ); 

    // later...

    if (UI(`AreYouSure("Erase Disk?"))) { /* ... */ }
}
</PRE>
</CODE></BLOCKQUOTE>
<P>The locales _("&amp;OK") and _("&amp;Cancel") are localized at the time the
macro is <I>defined</I>, because the whole block containing the definition
is going through the translator before it arrives at the UI. And this must be
that way because the UI cannot localize strings as we have shown above. If the
translator is set to German at the time of the macro definition, _("&amp;Yes")
will be replaced with probably "&amp;Ja" and the code fragment arriving at the
UI is this:
<P>
<BLOCKQUOTE><CODE>
<PRE>
{
    define AreYouSure(string text) ''{  
       OpenDialog(`VBox(`Label(text),
                                `HBox(`PushButton(`id(`ok), "&amp;Ja"),
                                      `PushButton("&amp;Nein"))));
               boolean ok = UserInput() == `ok;
               CloseDialog();
               return ok;
}
</PRE>
</CODE></BLOCKQUOTE>
<P>If the language setting is changed lets say to czech and the macro called
after that, the german texts will remain. Please understand that this is not a
bug in the implementation of the translator or UI nor a principle design flaw
in Y2 but a consequence of the separation of the UI and the module and the
feature of the UI that it is intelligent and allows you to persistently store
macros definitions. Compare it with X11. A client application will also send
localized strings to the X server. But the X server cannot store macros for
you, so the application has to send the strings each time again anyway.
<P>There are a couple of ways how you can avoid the problem:
<P>
<UL>
<LI>Don't use UI macros that contain locales, in an application where the
user can change the language setting at runtime.
</LI>
<LI>Redefine all macros in the UI whenever the user changes the language.
</LI>
<LI>If you write YCP module you can define the macros in the WFM instead of
the UI. Then the texts the macro definition contains are localized whenever
the macro is <I>called</I>. Of course the macro cannot be called in the UI
context then. The upper example would look like this:
</LI>
</UL>
<P>
<BLOCKQUOTE><CODE>
<PRE>
{
    define AreYouSure(string text) ''{
        UI(`OpenDialog(`VBox(`Label(text),
            `HBox(`PushButton(`id(`ok), _("&amp;Yes")),
                  `PushButton(_("&amp;No"))))));
        boolean ok = UI(`UserInput()) == `ok;
        UI(`CloseDialog()); 
        return ok;
    };

    // later... 

    if (AreYouSure("Erase Disk?")) { /* ... */ }
}
</PRE>
</CODE></BLOCKQUOTE>
<P>
<H2><A NAME="ss11.3">11.3 Difference of the Datatypes locale and string</A>
</H2>

<P>
<P>Things like _("some string constant") do have the special YCP
datatype locale. Locales are not strings! Locale become strings when going
through the translator. But up to this time they simply aren't. And for this
reason you must be careful if you write something like
<P>
<BLOCKQUOTE><CODE>
<PRE>
string text = _("The disk has ") + tostring(size) + _("Megabytes");
</PRE>
</CODE></BLOCKQUOTE>
<P>You <I>can</I> do this if the code is executed in the UI context because at
that time the locales are already strings. But in the WFM context it is not
possible. This again is not a bug nor design flaw but unavoidable consequence
of the semantics of translation. The WFM cannot construct a string if some
parts of the string are still language dependent. There is no thing as a
partially localized string. Consider this example, which is written for being
run in the WFM:
<P>
<BLOCKQUOTE><CODE>
<PRE>
{
    integer size = getSizeOfDisk(/* ... */);
    // WFM produces runtime error with this
    string text = _("The disk has ") +
                  tostring(size) + _(" Megabytes");

    UI(''{
        // works nicely, locales don't make it to the UI, but:
        // variable size is not known here!
        string text = _("The disk has ") + 
                      tostring(size) + _(" Megabytes");
    });

    // Trick!
    string text = UI(_("The disk has ")) +
                  tostring(size) + UI(_(" Megabytes"));
}
</PRE>
</CODE></BLOCKQUOTE>
<P>The upper trick forces the locales to go through the translator. The localized
string arrives at the UI, is there evaluated - to itself - and returned to the
WFM. Now it is a string and can be used as such. A disadvantage of the
solution is that each string localized that way has to make the way to the UI
and back. Another way it to introduce a macro in the UI that does the string
operation (and probably some more things):
<P>
<BLOCKQUOTE><CODE>
<PRE>
{
    UI(''{
        define doit(integer size) ''{
            string text = _("The disk has ") +
                          tostring(size) + _(" Megabytes");
                /* maybe some further operations anyway needed ... */
        };
    });
    
    UI(`doit(size));
}
</PRE>
</CODE></BLOCKQUOTE>
<P>A future extension of the translator and the wfm could be a wfm builtin
Translate() or T(), that gets a locale and sends it through the translator but
<I>not</I> through the UI(). The Y2TranslatedServer would be required to
recognize such requests and send an immediate answer without bothering the
actual user interface.
<P>
<P>Noch geplante Erklärungen:
<P>Kapitel beim Interpreter: definition scopes!
<P>Base cell noch genauer erklaeren mit dem doActualWork.
<P>As dem generic frontend die beiden Zeilen zitieren.
<P>Das Protokoll genauer erklaeren, mit dem result() Term. Erlaetern in wieweit
das bei stdio usw. realisiert ist. Eventuell zwei Begriffe einfuehren:
function call protocol and ASCII stream protocol FCP und ASP.
<P>
<P>
<HR>
Next
<A HREF="Y2Bible-10.html">Previous</A>
<A HREF="Y2Bible.html#toc11">Contents</A>
</BODY>
</HTML>
