<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
 <META NAME="GENERATOR" CONTENT="SGML-Tools 1.0.9">
 <TITLE>The YaST2 Component Architecture: The WorkFlowManager</TITLE>
 <LINK HREF="Y2Bible-10.html" REL=next>
 <LINK HREF="Y2Bible-8.html" REL=previous>
 <LINK HREF="Y2Bible.html#toc9" REL=contents>
</HEAD>
<BODY>
<A HREF="Y2Bible-10.html">Next</A>
<A HREF="Y2Bible-8.html">Previous</A>
<A HREF="Y2Bible.html#toc9">Contents</A>
<HR>
<H2><A NAME="s9">9. The WorkFlowManager</A></H2>

<P>
<P>
<H2><A NAME="ss9.1">9.1 The purpose of the WorkFlowManager</A>
</H2>

<P>
<P>The WorkFlowManager (WFM) is a client component that realizes other client
components by executing YCP scripts in an extended YCPInterpreter, the
WFMInterpreter. The wfm client component always takes three parameters: A YCP
value to execute, a YCP string defining the name of the client component and a
parameter list for the client component it realizes. Remember that a YCP block
of statements is just a special case of a YCP value. A YCP script can be any
YCP value, for example the integer 42.
<P>You can test the wfm realizing a client component with the name
<CODE>"fortytwo"</CODE> by executing the script that contains 42 if you type
<P>
<BLOCKQUOTE><CODE>
<PRE>
y2wfm wfm '(42)' '("fortytwo")' '([])' stdio
</PRE>
</CODE></BLOCKQUOTE>
<P>The result is 42. On stdout you get
<P>
<BLOCKQUOTE><CODE>
<PRE>
(result(42))
</PRE>
</CODE></BLOCKQUOTE>
<P>You can execute a block of statements instead of the number 42, which is
perhaps more fun, but in this example outputs the same result:
<P>
<BLOCKQUOTE><CODE>
<PRE>
y2wfm wfm '({ integer a=40; return a+2; })' '("fortytwo")' '([])' stdio
</PRE>
</CODE></BLOCKQUOTE>
<P>The wfm extends the YCPInterpreter with a few but important functions. All
begin with an uppercase letter in order to distinguish them from the builtin
functions of the YPCInterpreter. The even most important WFM functions are
these:
<P>
<DL>
<P>
<DT><B>Args()</B><DD><P>Returns the argument list. If you give a single integer
<I>n</I> as argument to <CODE>Args()</CODE> you get just the <I>n-1</I>'th
argument. You can test this easily by typing
<P>
<BLOCKQUOTE><CODE>
<PRE>
y2wfm wfm '(Args(2))' '("fortytwo")' '([17,true,"hirn"])' stdio
</PRE>
</CODE></BLOCKQUOTE>
<P>It is much easier, if you put your YCP script into a file named like the
component, suffix it with <CODE>.ycp</CODE>, call the thing like this:
<P>
<BLOCKQUOTE><CODE>
<PRE>
y2wfm fortytwo.ycp '(17)' '(true)' '("hirn")' stdio
</PRE>
</CODE></BLOCKQUOTE>
<P>
<DT><B>UI()</B><DD><P>Send a YCP value to the UI for evaluation. As every other
client component also the WFM keeps a pointer to a server component. This is
usually called the UI, as we learned in the section about the Y2 base
cell. <CODE>UI()</CODE> now sends a value to that. The value is then evaluated in
the context of the UI. You need to understand, that the UI has its own
fullfeatured YCP interpreter with its own variable and macro definitions. It
may even run on another machine. We will see how the UI works in the next
chapter. If you use stdio as user interface, you can see the commands coming
on the terminal and you also have to enter the return values in lack of a real
UI. Put the following lines into <CODE>add.ycp</CODE>
<P>
<BLOCKQUOTE><CODE>
<PRE>
{
    integer u = UI(`some_function());
    integer v = UI(`some_other_function());
    return u+v;
}
</PRE>
</CODE></BLOCKQUOTE>
<P>and execute it by typing <CODE>y2wfm add.ycp stdio</CODE>. You will see how the
user interface is asked for the evaluation of <CODE>some_function()</CODE> and
<CODE>some_other_function()</CODE>. If you reply by typing two integers you will
get them added.
<P>
<DT><B>CallModule()</B><DD><P>Calls a submodule. The parameters are a string with the
modulename and a list with the modules' arguments. You even can call another
wfm as submodule. Lets see if you can cope with the following example. It's
really tricky. You can see how the inner wfm also gets an argument list. The
second <CODE>Args(1)</CODE> call is evaluated by the sub wfm, not by the main one,
because it is quoted (see chapter quoting). Can you guess what's the result?
<P>
<BLOCKQUOTE><CODE>
<PRE>
y2wfm wfm '(Args(1) + CallModule("wfm", [Args(1), "sub", [3, 2]]))' '("top")' '([5,6])' stdio
</PRE>
</CODE></BLOCKQUOTE>
<P>If you try it out, you must enter <CODE>nil</CODE> a few times on stdin, because
wfm sends a couple of commands to the UI, and because we use 'stdio' as UI, we
have to play the role of the UI ourselves.
<P>
</DL>
<P>The WFM has quite a bunch of other functions, most of them doing input/output
like reading or writing files. Remember that due to safety reasons no IO
functions are available in the YCPInterpreter itself. A script run in the WFM
<I>can</I> do IO (and needs to). All WFM functions are documented in
<CODE>/usr/doc/packages/yast2</CODE>.
<P>
<P>
<H2><A NAME="ss9.2">9.2 The implementation of the WFM</A>
</H2>

<P>
<P>The implementation of the WFM is really simple. It consists of a subclass of
<CODE>YCPInterpreter</CODE> named <CODE>WFMInterpreter</CODE>, which overrides the
function <CODE>evaluateInstantiatedTerm()</CODE> and handles the different WFM
functions, and a class <CODE>Y2WFMComponent</CODE>, which implements the
<CODE>doActualWork()</CODE> method. It always gets three parameters, the first of
which is the script to evaluate in the WFMInterpreter. The third is the
parameterlist that is stored for later use by the <CODE>Args()</CODE> function.
<P>
<P>
<HR>
<A HREF="Y2Bible-10.html">Next</A>
<A HREF="Y2Bible-8.html">Previous</A>
<A HREF="Y2Bible.html#toc9">Contents</A>
</BODY>
</HTML>
