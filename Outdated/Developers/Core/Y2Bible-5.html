<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
 <META NAME="GENERATOR" CONTENT="SGML-Tools 1.0.9">
 <TITLE>The YaST2 Component Architecture: Components and the liby2</TITLE>
 <LINK HREF="Y2Bible-6.html" REL=next>
 <LINK HREF="Y2Bible-4.html" REL=previous>
 <LINK HREF="Y2Bible.html#toc5" REL=contents>
</HEAD>
<BODY>
<A HREF="Y2Bible-6.html">Next</A>
<A HREF="Y2Bible-4.html">Previous</A>
<A HREF="Y2Bible.html#toc5">Contents</A>
<HR>
<H2><A NAME="s5">5. Components and the liby2</A></H2>

<P>
<P>
<H2><A NAME="ss5.1">5.1 Components</A>
</H2>

<P>
<P>When you want a system to be flexible and easily extendable you soon come to
the conclusion, that is helpful to break up the thing into smaller pieces that
(a) can be individually replaced and (b) can be combined in different
ways. The pieces are then usually called "modules" or "plugins" or
"beans" or whatever. In Y2 we simply call them <I>components</I> because
the system is composed of them.
<P>In order to make them combinable they all have to speak a common language:
YCP. All data passed between components is YCP data. The representation can be
in ASCII, in form of C++ objects and maybe someday possibly a binary byte
stream. We have discussed this already in chapter.
<P>Examples of components are the two user interfaces <I>qt</I> and
<I>ncurses</I>, the system configuration repositor <I>scr</I>, the
workflow manager <I>wfm</I> and the configuration modules.
<P>
<H2><A NAME="ss5.2">5.2 Clients and Servers</A>
</H2>

<P>
<P>Y2 makes a distinction between two types of components: clients and
servers. They differ in how the execution control flows.
<P>A <I>server</I> component - once started - waits for commands. Once it
receives a command (which is an arbitrary YCP value) it <I>evaluates</I> it
and returns the answer (which also is a YCP value) and again waits for the
next command. At the end of the day it gets a <I>result</I> message
containing another YCP value and knows that it should terminate. Examples for
server components are the user interfaces and the scr.
<P>A <I>client</I> component takes over the control itself. You start it with a
parameter list, which is a YCP list. Then it works and does and accomplishes
and computes until it thinks that's enough and returns a <I>result</I>
value. It's much like a function call. Furthermore each client component keeps
a pointer to a server component it calls <I>user_interface</I>. It can use
this to display information to the user and get answers from him. Examples for
client components are the wfm and the configuration modules.
<P>Client and server are represented by C++ objects of the type
<CODE>Y2Component</CODE>. Each server must has a member function
<CODE>evaluate(YCPValue v)</CODE>, that evaluates a YCP value <CODE>v</CODE>. Each
client component has a member function <CODE>doActualWork(YCPList
parameter_list, Y2Component *user_interface)</CODE> that starts the client
component.
<P>
<H2><A NAME="ss5.3">5.3 The Base Cell</A>
</H2>

<P>
<P>When you start Y2 you do this by executing a Linux binary that is linked
against liby2. On the commandline you have to specify (after the name of the
binary) the name of a client component and the name of a server
component. There is no exception to this. You always need exactly one of
each. Together they form the Y2 <I>base cell</I>.
<P>
<P>The server component is called <I>user</I> <I>interface</I> in this
context, because it usually is one. The construction of the base cell is done
by the <I>generic frontend</I>. This is a generic <I>main() </I>function
contained in the liby2. All programs linked against liby2 get their main
function from the lib. Don't provide your own.
<P>The generic frontend creates the client and the server component and connects
both by calling <CODE>doActualWork(parameter_list, user_interface)</CODE>, where
<CODE>user_interface</CODE> is the server component. The client now begins to do
its work. Whenever user interaction is required, it can use the pointer to
<CODE>user_interface</CODE> to do so. When its finished <CODE>doActualWork</CODE>
returns a result value. The generic frontend passes this to the server by
calling its <CODE>result()</CODE> function and the servers knows that the show is
over.
<P>
<P>
<H2><A NAME="ss5.4">5.4 Component Creation</A>
</H2>

<P>
<P>
<H3>Creators and the Broker</H3>

<P>
<P>As we have just learned, the generic main function uses the commandline to
know which server and which client component should be created. But how does
the creation work?
<P>Each Y2 binary has compiled in a number of component types. Which components
go into a binary is decided at link time, not at compile time. It's like a bag
where you stuff everything into that you want to have handy. Remember that all
components that are in the same binary, can communicate very efficiently via
function calls. A component type is a subclass of Y2Component. For example the
Qt base user interface is a server component called <CODE>qt</CODE>. It is
realized by creating a subclass Y2QtComponent. You could create such a
component from within a C++ program by writing <CODE>new
Y2QtComponent(...)</CODE>. But the generic frontend has to decide which
components to create from the argument strings of the commandline. It does not
even know, which classes are available, because it is - well - generic.
<P>The generic frontend needs a way how to create an object of type Y2Component
(more precisely of a subclass) from a string, that specifies the name of the
component. If you give it the string "<I>qt</I>", it must do a <CODE>new
Y2QtComponent(...)</CODE>. But it can't know anything about a
<CODE>Y2QtComponent</CODE> class. This problem is solved by the concept of the
<I>component creators</I> and the <I>component broker</I>.
<P>A component creator is a C++ object of type <CODE>Y2ComponentCreator</CODE> that
can create a component. Therefore you call it's function <CODE>create(name)</CODE>
with <CODE>name</CODE> being the name of the component you want to create. If that
creator happens to know the component type you mean, it creates it for
you. Otherwise it returns 0.
<P>The <I>component broker</I> is a global instance that manages a pool of all
component creators. It is realized by the class <CODE>Y2ComponentBroker</CODE>,
which has only static functions. It again has two functions <CODE>createServer()</CODE> and <CODE>createClient()</CODE>, that create a component for you by scanning
all existing creators and asking them to create the component. The first that
can do this, creates the component.
<P>
<H3>Global constructors</H3>

<P>
<P>The component creators must be known to the component broker within the main()
function. And which creators are available is decided at link time. This is
realized by use of global constructors. For each component type, there is a
global variable of type <CODE>Y2ComponentCreator</CODE> (more precisely of a
subclass). The constructor of <CODE>Y2ComponentCreator</CODE> registers the
creator at the broker. Because the constructors of the global variables happen
before main() is entered, the broker is set up correctly when the generic main
function needs to create the components.
<P>
<H2><A NAME="ss5.5">5.5 Component types</A>
</H2>

<P>
<P>Y2 is highly modular and allows components to be spread over a whole
network. This is realized by different types of components. The coarse
classification is into builtin, adapter, script and plugin
<BLOCKQUOTE>Plugin
components are currently vaporware. They will be implemented for the SuSE 7.0
or 7.1.</BLOCKQUOTE>
 components.
<P>
<UL>
<LI> <B>Builtin components</B> are such ones that are implemented as C++
objects. Examples are <CODE>qt</CODE>, <CODE>ncurses</CODE>, <CODE>scr</CODE> and
<CODE>wfm</CODE>. If you don't want the components you use to be all in one
binary, you have to use adapter components.
</LI>
<LI> <B>Adapter components</B> are components that only act as components but
don't do the actual work themselves. They send the YCP values they get over
some kind of communication channel to another Y2 component or some other thing
at the other side of that channel.
</LI>
</UL>
<P>
<H3>Stdio Component</H3>

<P>
<P>The simplest adapter component is called <CODE>stdio</CODE>, because it
communicates via stdin/stdout. It can be instantiated as a server as well as
as a client. Let us for example assume it acts as a client and the server is
<CODE>qt</CODE>. You start such a session by typing <CODE>y2qt stdio
qt
<BLOCKQUOTE>The stdio component is contained in the liby2 and available in
each Y2 binary. The same holds for all other adapter components. Otherwise
they would be quite useless.</BLOCKQUOTE>
</CODE>.
<P>
<P>The client component is now no "real" component, but yourself typing YCP
values at your terminal windows. You can try this out by typing
<P>
<BLOCKQUOTE><CODE>
<PRE>
{
    OpenDialog(`PushButton("Hi!")); UserInput(); CloseDialog();
}
</PRE>
</CODE></BLOCKQUOTE>
<P>
<H3>Program Component</H3>

<P>
<P>In order to provide modularity, Y2 allows a component to be an external
program, rather then being a C++ object in the same binary. This feature is
completely transparent to the implementation of the code the uses the
component. If you want to create a component, for example by
<CODE>Y2ComponentBroker::createClient("module")</CODE>, the component broker first
looks for builtin components. If none with the name <CODE>module</CODE> can be
created, it looks for external programs that reside in
<CODE>/usr/lib/YaST2/clients</CODE> or <CODE>/usr/lib/YaST2/servers</CODE>. If it
finds an executable program there, it is started using the <CODE>program
component</CODE>, which is an adaptor component.
<P>The program component simulates a real component, by forking away a process
that starts a liby2 program and communicates with that process over a pair of
pipes. In this pipes ASCII representation of YCP is flowing. The forked away
program thus must communicate over its stdio, which it simply does by using
the <CODE>stdio</CODE> adaptor.
<P>
<P>
<H3>Remote Components</H3>

<P>
<P>
<H3>How they work</H3>

<P>
<P>The remote components are adaptor components, that connect to other machines
or start components as another user. They do this by using an existing
network protocol rather than inventing their own one.
<P>Currently you can choose between <CODE>telnet</CODE>, <CODE>rsh</CODE>,
<CODE>rlogin</CODE>, <CODE>ssh</CODE>, <CODE>su</CODE> and <CODE>sudo</CODE>. In order to use
one of these protocols you must have installed the corresponding command line
program and must be able to connect to the remote machine using this
program. It's best to try out the remote access to the other machine first by
using the command line program. Y2 does just the same. It forks away the
commandline program and controls it with a pair of pipes. It listens to and
tries to answer to its questions. The good news about this is that you don't
have to run any Y2 specific daemon on the target machine and the Y2 doesn't
open any new security holes. Using remote access with Y2 is as secure as your
security configuration is anyway.
<P>Take for example <CODE>telnet</CODE>. Y2 calls telnet as external process
specifying the remote machine on telnet's command line. Telnet connects to the
other machine and eventually prints something like <CODE>Hirn login:</CODE>. In
answer to this prompt Y2 sends the proper login name. In answer to
<CODE>Password:</CODE> Y2 provides the password. As soon as the prompt appears, Y2
issues the command line for starting the Y2 binary that finally realizes the
component, again with stdio as adaptor - much like program component does.
<P>The implementation of the remote adaptors is in <CODE>Y2RemoteComponent</CODE> and
<CODE>Y2RshProtocol</CODE>, <CODE>Y2TelnetProtocol</CODE>, ...
<P>
<H3>How they are used</H3>

<P>
<P>The <I>name</I> of a remote component is much more complex then the one of a
builtin or program component, since it must encode the remote machine and the
login there. It has the following form (much like a URL):
<P><CODE>&lt;protocol&gt;://&lt;user&gt;@&lt;host&gt;/&lt;component&gt;</CODE>, or
<P><CODE>&lt;protocol&gt;://&lt;host&gt;/&lt;component&gt;</CODE>, or
<P><CODE>&lt;protocol&gt;://&lt;user&gt;/&lt;component&gt;</CODE>, in case of su and
sudo
<P>Protocol is one of <CODE>telnet</CODE>, <CODE>rsh</CODE>, <CODE>rlogin</CODE>,
<CODE>ssh</CODE>, <CODE>su</CODE> and <CODE>sudo</CODE>. Su and sudo are used to log into
the local machine but as a different user. Examples for a commandline that
starts the client component <CODE>logcontrol</CODE> on the machine
<CODE>Herstein.suse.de</CODE> as user <CODE>kettner</CODE>:
<P>
<BLOCKQUOTE><CODE>
<PRE>
y2qt telnet://kettner@Herstein.suse.de/logcontrol qt
</PRE>
</CODE></BLOCKQUOTE>
<P>The component the be launched on the remote machine can again be a remote
component, of course. For example if root login from a remote host is disabled
on Herstein, but a login as kettner is possible and kettner is allowed to use
sudo (see sudo man page for details), you can start logcontrol as root on
Herstein using this line:
<P>
<BLOCKQUOTE><CODE>
<PRE>
y2qt telnet://kettner@Herstein.suse.de/sudo://root/logcontrol qt
</PRE>
</CODE></BLOCKQUOTE>
<P>
<H3>The problem with the password</H3>

<P>
<P>One problem appears with some of the protocols, as you may have guessed. It's
because some of them need a password for logging in. In case the remote
component you want to start is a <I>client</I> component, this is solved by
simply asking the user (you) for the password. This can be done, because each
client component (and the remote adaptor component <I>is</I> a client
component in this case) has access to the user interface. The liby2 calls the
module <CODE>password</CODE> for this task. You find it in
<CODE>/usr/lib/YaST2/clients</CODE>.
<P>If you want to call a <I>server</I> component remote, currently you have bad
luck. We are working on it. If you can login without password, you're lucky
because this is simple. But if a password is needed, we have a problem,
because the user cannot be asked for it. A server component has no access to
the user interface. Maybe itself <I>is</I> the user interface. Rsh, ssh and
sudo can be configured to work without password. This configuration lies
beyond the scope of Y2.
<P>
<H3>Security</H3>

<P>
<P>Since Y2 is layered on top of existing highlevel protocols, it is at least as
secure as these protocols.
<P>
<H3>Serial Component</H3>

<P>
<P>
<H3>What it does</H3>

<P>
<P>The serial component allows you to connect two Y2 components with a serial
line. The component name encodes the baud rate and the device to use. For
communication there is always used 8,N,1
<BLOCKQUOTE>8 data bits, no parity bit,
one stop bit.</BLOCKQUOTE>
. Currently the handshaking is fixed to RTS/CTS.
<P>The serial component is for example used by the Y2 installer to allow the
installation of a server computer that has neither keyboard nor graphics
adaptor. Instead of this you use a Linux workstation, connect one of its
serial connectors with the first serial connector of the server to be
installed, insert the boot CD into the server and boot it. On the Linux
workstation you start
<P>
<BLOCKQUOTE><CODE>
<PRE>
y2qt serial(115200):/dev/ttyS0 qt
</PRE>
</CODE></BLOCKQUOTE>
<P>Instead of a 'read' Y2 client component, an YCP ASCII communication over the
serial interface <CODE>/dev/ttyS0</CODE> is established. On the server computer in
that shell script that initiates the installation you'll find a matching line
like this:
<P>
<BLOCKQUOTE><CODE>
<PRE>
y2base installation serial(115200):/dev/ttyS0
</PRE>
</CODE></BLOCKQUOTE>
<P>Here the server component, which takes the role of the user interface, is
implemented by the serial component and the client component
<CODE>installation</CODE> is the local module that does the installation of the
system.
<P>
<H3>Specialties</H3>

<P>
<P>The serial component deals with two properties that are special to it and that
are induced by the inherent properties of a serial connection:
<P>
<UL>
<LI>The Y2 session is <I>symmetric.</I> No component creates the other like
the other adaptor components. Both corresponding halves must be created by the
user.
</LI>
<LI>The serial line may loose characters. There is no way to determine
whether on the other side of the cable somebody <I>listens</I>. You just can
hear if somebody <I>sends</I> data. Bytes you send when nobody is listening
on the other side are lost for ever.
</LI>
</UL>
<P>From these facts evolves the need for some kind of <I>protocol</I> that
envelopes the YCP communication. It is done by the serial component like this:
<P>When you create a serial component, it begins to send <I>spaces</I> (ASCII
32) over the serial interface and at the same time listens for spaces coming
from the other side of the cable. If it has successfully read
<I>n</I>&nbsp;subsequent spaces
<BLOCKQUOTE><I>n</I> is currently set to
16.</BLOCKQUOTE>
, it assumes that the other side is a matching Y2 serial
component that is listening. It then continues to send another <I>n</I>
spaces in order to make sure the other side also gets its <I>n</I>
spaces. It is assumed that - once the connection works - no character can be
lost.
<P>After that it enters the normal YCP protocol mode. The client component sends
the first YCP value, which is either a command for the server or a result
value (which terminates the connection). The server answers and so on. The
good thing about doing the synchronization with spaces is, that any valid YCP
syntax keeps valid if you prefix it with spaces. If one side already enters
YCP mode and the other continues to send a few spaces, no harm is done.
<P>One other specialty is that the serial component has a timeout parameter. If
you set this parameter than the serial component aborts the connection tries
after a given period. This is used by the installer. The timeout is currently
only available for the server serial component.
<P>
<H3>Getty Component</H3>

<P>
<P>The getty component is not yet implemented. It also makes use of a serial
line, but does an <I>asymmetrical</I> session. It is very similar to the
remote components. The other machine needs a running getty process. The getty
component logs into another machine using a serial line connecting to that
getty process, "types in" the login name and the password and issues a command
that starts a component with the adaptor component stdio. The implementation
should be nearly identical to that of the telnet component.
<P>Because for logging into a getty a password is always needed, this currently
only works for starting client components.
<P>The pseudo URL has the form
<CODE>getty(&lt;baudrate&gt;)://&lt;login&gt;@&lt;device&gt;/&lt;component&gt;</CODE>,
for example:
<P>
<BLOCKQUOTE><CODE>
<PRE>
getty(9600)://kettner@/dev/ttyS0//logcontrol
</PRE>
</CODE></BLOCKQUOTE>
<P>
<H3>Scripting Components</H3>

<P>
<P>Scripting components are a very important type of components. A scripting
component is one that is written in YCP. Currently this works for client
components only. A scripting component is implemented by a YCP file that is
lies in <CODE>/usr/lib/YaST2/clients
<BLOCKQUOTE>and some other paths. We'll come
the that later.</BLOCKQUOTE>
</CODE> and suffixed with <CODE>.ycp</CODE>.
<P>There is a special component creator that handles YCP scripts. It's
implemented in Y2ScriptingComponent. When it is asked to create a component
named, let's say, hirn (i.e. when its create() function is called with the
string "hirn" as module name) it looks into <CODE>/usr/lib/YaST2/clients</CODE>
for a file named <CODE>hirn.ycp</CODE> containing a valid YCP value. If this is
the case, it creates the client component <CODE>wfm</CODE>, the WorkFlowManager
and passes it the YCP value for execution.
<P>The WorkFlowManager executes the script and handles some additional YCP
commands, the most important of which is <CODE>UI()</CODE>. It is used to send a
command to the user interface. If you remember the Y2 base cell and the wfm
always implements a client component, you'll see the <CODE>UI()</CODE> in fact
send the command to the server part of this base cell.
<P>
<H3>Plugin Components</H3>

<P>
<P>Plugin components are not yet implemented but urgently planned. They realize a
server or client component by loading an ELF shared library plugin. The
corresponding component broker looks into <CODE>/usr/lib/YaST2/clients</CODE> or
<CODE>/usr/lib/YaST2/servers</CODE> for <CODE>&lt;componentname&gt;.so</CODE>. If it
finds something, it loads the plugin using the libdl and has now access to a
function that can create a builtin component - a real subclass of
Y2Component. The details have yet to be worked out.
<P>The advantage of this approach is that it is much more modular than real
builtin components that must be packaged at compile time but the communication
is as efficient, since function calls can be used instead of serialization.
<P>
<H2><A NAME="ss5.6">5.6 Levels</A>
</H2>

<P>
<P>
<P>
<HR>
<A HREF="Y2Bible-6.html">Next</A>
<A HREF="Y2Bible-4.html">Previous</A>
<A HREF="Y2Bible.html#toc5">Contents</A>
</BODY>
</HTML>
