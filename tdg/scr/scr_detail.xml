<?xml version="1.0" encoding='ISO-8859-1'?>
<!-- =============================================================== -->
<!--
File         : scr_detail.xml
Author       : Thomas Rölz 
Initial date : 2002/10/23
CVS          : $Id: scr_detail.xml 173 2006-11-27 10:00:52Z locilka $
-->
<!-- =============================================================== -->

  <book id="Book-SCRDetails">
    <bookinfo>
      <title>Access to the System (SCR in General)</title>
    </bookinfo>

    <para>
      In the introductory chapter we have already heard something about
      accessing the system with SCR. Because manipulating the system at the
      lowest layer is all &prog; is about, we now want to take a closer look at
      this topic.
    </para>
    <para>
      Basically the SCR creates a consistent view of the system hardware and
      its configuration files. There are many dependencies between the
      different entities among those data and these dependencies have to be
      taken into consideration when manipulating them. For this being possible
      in a convenient way for the higher-level modules there must be an easy
      and consistent accessing method. This method is provided by the SCR as it
      presents kind of an abstraction of the various types of data to be
      handled.
    </para>
    <para>
      Now the data <quote>landscape</quote> that must be covered here is rather
      heterogeneous. Hardware data and configuration data, both of most
      multifaceted type can hardly be handled by one single monolithic program.
      Therefore the SCR consists of a <quote>head</quote> that is accompanied
      by various helper programs, the so-called agents, each of them being
      specialized on a specific task.
    </para>


    <chapter id="id_scr_agents">
      <title>SCR Agents</title>
      <para>
	For each category of system data there is a corresponding SCR-agent.
	Their job is to map the real system data to &lg;-data structures so
	that &lg;-modules can access them in a convenient way. In fact the
	SCR-agents <emphasis>provide</emphasis> the &lg; data structures.
	They come into existence with the presence of an SCR-agent that
	provides them. Otherwise they wouldn't be there.
      </para>
      <para>
	For example there is an agent that reads and writes the
	<literal>/etc/sysconfig</literal> files. The &lg;-representation of a
	<literal>sysconfig</literal>-variable is a single &lg;-string. When
	reading, the agent reads the variable in the corresponding file and
	creates a &lg;-string from it. When writing, the agent gets the new
	value as &lg;-string and changes the variable in the corresponding file
	accordingly. 
      </para>
      <para>
	It must be said here, that the set of agents may change over time. New
	agents may be created in the future and other ones might be abandoned
	if their functionality is obsolete or taken over by another agent.
	Generally this is no problem because for module development it is not
	(and should not be) necessary to know exactly which agent does what. As
	already said, the SCR provides an abstraction of the data to be handled
	and this abstraction comes into being in form of a tree, the SCR-tree.
      </para>
    </chapter>

    <chapter id="id_scr_tree">
      <title>SCR Tree</title>
      <para>
	As a computer's hardware and software configuration is quite complex,
	the SCR organizes all data in form of a tree. It resembles very much a
	file system with its folders, sub-folders and files whereby the tree
	structure reflects the thematic separation of the various
	configuration categories.
      </para>
      <para>
	The SCR-tree consists of two different kinds of nodes:
      </para>

      <table frame="all">
	<title>SCR Node Types</title>
	<tgroup cols="2" align="center">
	  <colspec colwidth="80"/>
	  <colspec colwidth="320"/>
	  <tbody>
	    <row valign="middle">
	      <entry>Data nodes</entry>
	      <entry align="left">
		Data nodes represent single pieces of data, for example a
		<literal>sysconfig</literal>-entry or a mountpoint of a
		file system in <literal>/etc/fstab</literal>. They are the
		<emphasis>leaves</emphasis> of the tree and stand for actual
		data to be handled. 
	      </entry>
	    </row>
	    <row valign="middle">
	      <entry>Map nodes</entry>
	      <entry align="left">
		Map nodes allow for navigation to the leaves just like the path
		components in the directory structure of a file system. This
		way map nodes are used to structure the data in a suitable
		manner.
	      </entry>
	    </row>
<!-- Not to be documented (currently unused) but leave it in (never know). -->
<!--
	    <row valign="middle">
	      <entry>List nodes</entry>
	      <entry align="left">
		A list node is a special kind of map node that assigns numbers
		to its descendants instead of names. Generally speaking they
		are used if the data to be presented can not be identified by
		names so that it has to be enumerated. In that sense they
		represent data that is countable, such as the content of the
		<literal>/etc/fstab</literal>.
	      </entry>
	    </row>
-->
	  </tbody>
	</tgroup>
      </table>

      <para>
	The names of the nodes in the SCR-tree can be concatenated resulting in
	the creation of an <emphasis>SCR-path</emphasis>. An SCR-path is a
	description were to find a node in the SCR-tree. It is a sequence of
	path components each of them being a string. As we have seen in the
	section	<xref linkend="id_ycp_data_path"/> &lg;-paths are prepended by
	dots (.) which act as separators in compound paths. So
	<literal>.foo.bar</literal> is a valid &lg;-path. If
	<literal>bar</literal> is an SCR data node, then
	<literal>SCR::Read(.foo.bar)</literal> would render some data. If
	<literal>bar</literal> is a map node, then
	<literal>SCR::Dir(.foo.bar)</literal> would reveal the immediate
	sub-nodes in the SCR-tree, e.g. <literal>["big", "brown",
	  "fox"]</literal>. The single dot (.) is also valid and denotes the
	root of the whole SCR-tree. Consequently <literal>SCR::Dir(.)</literal>
	will return a list of all the top-nodes in the SCR-tree.
      </para>
      <para>
	In the figure below we see a (very small) cut-out of the SCR-tree that
	is related to hardware-specific information.
      </para>
      <beginpage/>
     
      <figure>
	<title>SCR Hierarchy Tree</title>
	<mediaobject>
	  <imageobject role="pdf">
	    <!-- Formats OK: PNG -->
	    <imagedata 
                fileref="images/scr/scr-tree-pdf.png" scale="18" align="center"/>
	  </imageobject>
	  <imageobject role="html">
	    <!-- Formats OK: PNG -->
	    <imagedata 
                fileref="images/scr/scr-tree-html.png" scale="100" align="center"/>
	  </imageobject>
	</mediaobject>
      </figure>
      <!--Old: fileref="/usr/share/doc/packages/yast2-core/scr/scr-tree.png"-->
      
      <para>
	The light gray nodes are SCR-map-nodes denoting the path to the data.
	They can be used with <literal>SCR::Dir(...)</literal> to find out what
	is below. So in the figure above <literal>SCR::Dir(.probe)</literal>
	would return a list as <literal>[..."has_smp", "boot_arch",
	  "has_apm"...]</literal>.
      </para>
      <para>
	The dark grey nodes are SCR-data-nodes that stand for the actual data.
	What can be done with them depends on the actual node (reading,
	writing, executing), but usually <literal>SCR::Read(...)</literal> is
	possible. As is shown above
	<literal>SCR::Read(.probe.boot_arch)</literal> would return
	<literal>"grub"</literal>.
      </para>
    </chapter>

    <chapter id="id_scr_access">
      <title>Accessing SCR</title>

      <para>
	Now that we know how the SCR-landscape can be navigated we will take a
	look at how the data that is dug in there can be accessed. The
	accessing methods already implied above shall now be defined more
	precisely.
      </para>
      <para>
	There are four accessing methods.
      </para>

      <itemizedlist>
	<listitem>
	  <para><emphasis>Reading</emphasis></para>
	  <para>
	    We speak of <emphasis>reading</emphasis>, when the agent reads some
	    configuration file or scans the system hardware and produces a YCP
	    data structure representing this information.
	  </para>
	</listitem>
	<listitem>
	  <para><emphasis>Writing</emphasis></para>
	  <para>
	    We speak of <emphasis>writing</emphasis>, when the agent gets some
	    YCP data structure and creates or modifies some system configuration file
	    according to these data. 
	  </para>
	</listitem>
	<listitem>
	  <para><emphasis>Executing</emphasis></para>
	  <para>
	    We speak of <emphasis>executing</emphasis>, when the agent gets
	    some YCP data that can be interpreted as instruction and executes
	    it. Usually this is being done by means of another program, e.g.
	    the <literal>bash</literal>.
	  </para>
	</listitem>
	<listitem>
	  <para><emphasis>Dir</emphasis></para>
	  <para>
	    Compared to the other accessing methods listed above, the
	    <emphasis>Dir</emphasis>-command is somewhat special. It takes as
	    argument an SCR-path that points to a specific node in the
	    SCR-tree. It returns a list of all the sub-paths that are
	    immediately below this node. This way it works just like a
	    <emphasis>dir</emphasis>-command in a file system. For example if
	    you apply this to the root of the SCR-tree (.), the answer would be
	    a list with all the top nodes known by the SCR , e.g.
	    <literal>["audio", ... , "yast2"]</literal>.
	    <footnote>
	      <para>
		Unfortunately not all SCR-agents do support this command
		properly. There may be agents that wrongly return an empty list
		or even <literal>nil</literal> when queried this way.
	      </para>
	    </footnote>
	  </para>
	</listitem>
      </itemizedlist>

      <para>
	As a rule all SCR-agents implement some of the four accessing methods
	listed above. However depending on the task the agent was made for, not
	<emphasis>all</emphasis> of them may be provided.
      </para> 

      <para>
	For convenient use from &lg; the accessing methods are realized by
	means of an <emphasis>API</emphasis>, i.e. a defined set of
	&lg;-functions that are understood. You can call these functions from
	&lg; if you prepend the commands with the name space identifier
	<literal>SCR::</literal> which causes redirection to the SCR.
      </para> 
 
      <table frame="all">
	<title>The SCR-commands</title>
	<tgroup cols="2" align="center">
	  <colspec colwidth="220"/>
	  <colspec colwidth="180"/>
	  <thead>
	    <row>
	      <entry>Function</entry>
	      <entry>What it does</entry>
	    </row>
	  </thead>
	  <tbody>
	    <row valign="middle">
	      <entry>
		<literal>Read(path p) -&gt; any</literal>
	      </entry>
	      <entry align="left">
		Reads the data represented by the node at path
		<literal>p</literal>. The value returned can be any &lg; data
		type but it is always one single value.
	      </entry>
	    </row>
	    <row valign="middle">
	      <entry>
		<literal>Write(path p, any v) -&gt; boolean</literal>
	      </entry>
	      <entry align="left">
		Writes the value <literal>v</literal> to the node at path
		<literal>p</literal>. The boolean return value is
		<literal>true</literal> on success. On error the return value
		is <literal>false</literal> and a log entry is generated in the
		log file. Reasons for errors can be a mistyped value
		<literal>v</literal> or some problem with the periphery that
		lies behind the data-node.
	      </entry>
	    </row>
	    <row valign="middle">
	      <entry>
		<literal>Execute(path p) -&gt; boolean</literal>
	      </entry>
	      <entry align="left">
		This command is mostly used with the
		<literal>system-agent</literal> (see <xref
		  linkend="id_scr_existing_agents"/>). Usually the return value
		indicates success or failure of the executed command. 
	      </entry>
	    </row>
	    <row valign="middle">
	      <entry>
		<literal>Dir(path p) -&gt; list(string)</literal>
	      </entry>
	      <entry align="left">
		Returns a list of all subtree nodes immediately below the node
		<literal>p</literal>. For each such node the list contains a
		string denoting its name. If <literal>p</literal> does not
		point to a map node, i.e. the last path component is a leaf,
		the command will return an empty list or
		<literal>nil</literal>.
	      </entry>
	    </row>
	  </tbody>
	</tgroup>
      </table>
    </chapter>

    <!-- FIXME: Because of time shortness this must be done later -->
    <chapter id="id_scr_ycp" role="tobedonelater">
      <title>Using SCR From Within YCP</title>
      <para>
	FIXME: To be done... (Examples?)
      </para>
    </chapter>

    <chapter id="id_scr_command">
      <title>Using SCR From The Command Line</title>
      <para>
	In the last section we saw some examples of how the SCR can be used
	from &lg;. However if you only want to test or explore different
	SCR-paths, writing a &lg;-script for every access can be cumbersome.
	Fortunately the SCR-component can be run individually on the command
	line of a terminal using a method very similar to the one we saw in
	<xref linkend="Commandline-library"/>.
      </para>
      <para>
	In contrast to the method demonstrated there, this time we don't feed
	a &lg;-script into &prog;. Instead we make another use of the
	architectural separation of components featured by &prog; in that we
	connect the so-called <emphasis>stdio-component</emphasis> with the
	<emphasis>SCR-component</emphasis>. By doing so we can feed everything
	we type on the command line into the SCR.
      </para>
      <para>
	However, because of the <quote>raw</quote> nature of the
	&prog;-internal communication paths, this method is not very
	comfortable. You can't correct typos with
	<keycap>Backspace</keycap> or <keycap>Del</keycap> here (the
	SCR is not <emphasis>meant</emphasis> to be operated in this way). By
	doing so we kind of <quote>simulate</quote> &prog;-internal
	communication which normally forecloses any misspelling.
      </para>
      <para>
	Furthermore, if you play around with the SCR in this manner you will be
	able to initiate privileged actions only if you are running the
	commands under the <emphasis>root-account</emphasis>.  
      </para>
      <caution>
	<para>
	  If you run <quote>manual</quote> SCR-commands under the root-account,
	  the SCR will <quote>gracefully</quote> fulfill all your wishes. So be
	  careful with <emphasis>Write</emphasis> and
	  <emphasis>Execute</emphasis>!!!
	</para>
      </caution>
      <para>
	Now operating the SCR this way can be shown best with some examples.
      </para>
      <example>
	<title>Operating the SCR from the command line</title>
	<screen width="80">
$&gt; /usr/lib/YaST2/bin/y2base stdio scr
([])
`Read(.probe.boot_arch)
("grub")
`Read(.probe.version)
("Oct  7 2002, 15:05:08")
`Read(.probe.has_smp)
(false)
`Read(.probe.has_apm)
(true)
`Read(.probe.boot_arch)
(nil)
	</screen>
      </example>
      <para>
	As is shown above, the command <command>y2base stdio scr</command>
	starts &prog; in a specific way. It connects the &prog;
	client-component <emphasis>stdio</emphasis> with the server-component
	<emphasis>scr</emphasis>. After that the SCR is running and awaits any
	input on stdio which in this case is the console. To explore the
	content of the SCR-tree you can now enter any SCR-commands just as you
	would do in &lg;. The only difference is the absence of the
	<literal>SCR::</literal> name space identifier which must not be given
	here as can be seen in the last line.
      </para>
    </chapter>

    <chapter id="id_scr_existing_agents">
      <title>Useful SCR Agents</title>

      <para>
	The SCR-world knows many agents for all sorts of tasks. Unfortunately
	this matter is subject to a rather high change service and not (yet)
	well documented. Therefore it is not easily possible to explain the
	details in a manner of <quote>Which agent provides which paths for what
	  reason?</quote>. As a result only the most helpful agents are
	mentioned here along with references to the respective developers
	documentation.
      </para>
      <para>
	Please note that even the developers documentation might be outdated to
	some extent. Consequently the most reliable source of information are
	the <quote>real</quote> files below
	<literal>/usr/share/YaST2/</literal>.
      </para>

      <itemizedlist>
	<listitem>
	  <para>
	    System Agent
	  </para>
	  <para>
	    This agent realizes access to the target system during
	    installation. 
	  </para>
	  <para>
	    <!-- HTML version points to the local copy but mentions the "real" file (Web)--> 
	    <ulink
	      url="instdoc_subset/yast2-core/agent-system/ag_system-builtins.html"
	      role="html">
	      /usr/share/doc/packages/yast2-core/agent-system/ag_system-builtins.html</ulink>
	    <!-- PDF version points directly to the "real" file -->
	    <ulink url="/usr/share/doc/packages/yast2-core/agent-system/ag_system-builtins.html"
	      role="pdf"/>
	  </para>
	</listitem>
	<listitem>
	  <para>
	    Background Agent
	  </para>
	  <para>
	    This agent runs shell commands in the background.
	  </para>
	  <para>
	    <!-- HTML version points to the local copy but mentions the "real" file (Web)--> 
	    <ulink
	      url="instdoc_subset/yast2-core/agents-perl/ag_background.html"
	      role="html">
	      /usr/share/doc/packages/yast2-core/agents-perl/ag_background.html</ulink>
	    <!-- PDF version points directly to the "real" file -->
	    <ulink url="/usr/share/doc/packages/yast2-core/agents-perl/ag_background.html"
	      role="pdf"/>
	  </para>
	</listitem>
	<listitem>
	  <para>
	    Hardware Probe Agent
	  </para>
	  <para>
	    The agent being responsible for hardware probing.
	  </para>
	  <para>
	    <!-- HTML version points to the local copy but mentions the "real" file (Web)--> 
	    <ulink
	      url="instdoc_subset/yast2-core/agent-probe/hwprobe.html"
	      role="html">
	      /usr/share/doc/packages/yast2-core/agent-probe/hwprobe.html</ulink>
	    <!-- PDF version points directly to the "real" file -->
	    <ulink url="/usr/share/doc/packages/yast2-core/agent-probe/hwprobe.html"
	      role="pdf"/>
	  </para>
	</listitem>
	<listitem>
	  <para>
	    Any-Agent
	  </para>
	  <para>
	    This agent handles the access to configuration files of (almost)
	    arbitrary syntax. The syntax to be understood must be specified in
	    a configuration file.
	  </para>
	  <para>
	    <!-- HTML version points to the local copy but mentions the "real" file (Web)--> 
	    <ulink
	      url="instdoc_subset/yast2-core/agent-any/anyagent.html"
	      role="html">
	      /usr/share/doc/packages/yast2-core/agent-any/anyagent.html</ulink>
	    <!-- PDF version points directly to the "real" file -->
	    <ulink url="/usr/share/doc/packages/yast2-core/agent-any/anyagent.html"
	      role="pdf"/>
	  </para>
	</listitem>
	<listitem>
	  <para>
	    Ini-Agent
	  </para>
	  <para>
	    The Ini-agent is suitable for accessing configuration files with the
	    well-known ini-file syntax.
	  </para>
	  <para>
	    <!-- HTML version points to the local copy but mentions the "real" file (Web)--> 
	    <ulink
	      url="instdoc_subset/yast2-core/agent-ini/ini.html"
	      role="html">
	      /usr/share/doc/packages/yast2-core/agent-ini/ini.html</ulink>
	    <!-- PDF version points directly to the "real" file -->
	    <ulink url="/usr/share/doc/packages/yast2-core/agent-ini/ini.html"
	      role="pdf"/>
	  </para>
	</listitem>
	<listitem>
	  <para>
	    Modules Agent
	  </para>
	  <para>
	    This agent is the interface to the
	    <literal>/etc/modules.conf</literal> file.
	  </para>
	  <para>
	    <!-- HTML version points to the local copy but mentions the "real" file (Web)--> 
	    <ulink
	      url="instdoc_subset/yast2-core/agent-modules/modules.html"
	      role="html">
	      /usr/share/doc/packages/yast2-core/agent-modules/modules.html</ulink>
	    <!-- PDF version points directly to the "real" file -->
	    <ulink url="/usr/share/doc/packages/yast2-core/agent-modules/modules.html"
	      role="pdf"/>
	  </para>
	</listitem>
	<listitem>
	  <para>
	    Perl Agent
	  </para>
	  <para>
	    This agent is a means to call Perl scripts from within &lg;. 
	  </para>
	  <para>
	    <!-- HTML version points to the local copy but mentions the "real" file (Web)--> 
	    <ulink
	      url="instdoc_subset/yast2-core/agents-perl/ycp-pm.html"
	      role="html">
	      /usr/share/doc/packages/yast2-core/agents-perl/ycp-pm.html</ulink>
	    <!-- PDF version points directly to the "real" file -->
	    <ulink url="file:///usr/share/doc/packages/yast2-core/agents-perl/ycp-pm.html"
	      role="pdf"/>
	  </para>
	</listitem>
      </itemizedlist>
    </chapter>
  </book>

<!-- ====== Allow emacs psgml to parse the document hierarchy ====== -->
<!-- ATTENTION * This MUST be at the end of the document * ATTENTION -->
<!--
Local Variables:
sgml-parent-document: ("yast_intro.xml")
End:
-->
<!-- ====== Allow emacs psgml to parse the document hierarchy ====== -->
