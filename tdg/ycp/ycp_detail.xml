<?xml version="1.0" encoding='ISO-8859-1'?>
<!-- =============================================================== -->
<!--
File         : ycp_detail.xml
Author       : Thomas Rölz 
	       Stanislav Visnovsky
	       Lukas Ocilka
Initial date : 2002/10/23
CVS          : $Id: ycp_detail.xml 183 2007-01-09 15:48:57Z locilka $
-->
<!-- =============================================================== -->

  <book id="Book-YCPLanguage">
    <bookinfo>
      <title>The &prog_t; Programming Language - YCP</title>
    </bookinfo>

    <para>
      The &prog;-language &lg; is a scripting language to be interpreted by the
      &lg;-engine (&lg; interpreter) specially designed for 
      manipulation with a system configuration. Its syntax is very similar
      to C programming language. 
      Because &lg; can make use of the whole infrastructure that
      &prog; provides, the actions that can be accomplished with &lg; are
      very powerful.
    </para>
    <para>
      &lg; has the usual features of procedural languages and
      some more, partially originating from the functional 
      programming paradigm:
    </para>

    <itemizedlist>
      <listitem>
        <para>Control structures like if/then/else, foreach-loops.</para>
        </listitem>
      <listitem>
          <para>Compound data types like strings, lists and maps.</para>
      </listitem>
      <listitem>
        <para>Function definition (procedures)</para>
      </listitem>
      <listitem>
        <para>Variable scopes</para>
      </listitem>
      <listitem>
        <para>Name spaces</para>
      </listitem>
      <listitem>
        <para>Include files</para>
      </listitem>
      <listitem>
        <para>UNIX command execution (via the &prog_t; infrastructure)</para>
      </listitem>
    </itemizedlist>

    <para>
      On the following pages we will explore the &lg; language definition and
      find out how to use &lg; to write <quote>programs</quote> that can be
      executed by &prog;.
    </para>

    <!-- ############################################################## -->

    <chapter id="id_ycp_first">
      <title>The First &lg_t; Program</title>
      <para>
        Probably the best way to get into the matter is by means of a simple
        example.
      </para>
      
      <section id="id_ycp_hello">
        <title>&lg_t; Source</title>	
	<para>
	  The following little program opens a window that displays the
          string <quote>Hello, World!</quote> and provides a push button for
          termination.
        </para>

        <example id="id_ycp_helloex">
          <title><quote>Hello World</quote> in &lg_t;</title>
          <programlisting width="80">
{
    string message = "Hello, World!";
    
    UI::OpenDialog(
               `VBox( 
                     `Label( message ),
                     `PushButton("&amp;OK")
                    )
              );

    UI::UserInput();

    UI::CloseDialog();
}
          </programlisting>
        </example>
      
        <para>
          In the following this code will be explained shortly in a line-by-line
          manner thereby touching some topics we will examine in detail later on.
        </para>

        <itemizedlist>
          <listitem>
            <para><literal>{</literal></para>
            <para>
              The opening curly opens a so-called
              <emphasis>block</emphasis> in &lg;. Blocks are used to
              <quote>glue</quote> several &lg;-statements together to form an
              entity that can be handled just like a single statement.
            </para>
          </listitem>
          <listitem>
            <para><literal>string message = "Hello, World!";</literal></para>
            <para>
              In this line we define a variable named <quote>message</quote> that
              is of type <type>string</type>. In &lg; any variable definition
              <emphasis>must</emphasis> imply a value assignment to avoid all
              errors that might occur due to uninitialized variables. Here we
              assign the constant string <quote>Hello, World!</quote>.
              Furthermore the terminating semicolon is mandatory in &lg; to
              indicate the end of a statement (just like C).
            </para>
          </listitem>
          <listitem>
            <para><literal>UI::OpenDialog(</literal></para>
            <para>
              This command opens a dialog on screen. 
	      Because we want to display something, the code describing our
              dialog has to be sent to the UI. This is being done by the leading
              name space identifier <literal>UI::</literal>. The (single) parameter that
              is supplied here determines the content of the dialog. 
            </para>
          </listitem>
          <listitem>
            <para><literal>`VBox(</literal></para>
            <para>
              This is a UI-statement related to the geometry of the dialog to be
              defined. As the name indicates it opens a (virtual)
              <emphasis>vertical box</emphasis> that displays all content in a
              column-wise manner. (Geometry management is described in more
              detail in <xref linkend="id_ycp_ui"/>).
            </para>
            <para>
              The leading back-quote introduces a &lg;-feature that stems from
              the functional programming paradigm. In &lg;-speak the
              <literal>`VBox()</literal> is a <emphasis>term</emphasis>. In &lg;, 
	      terms are used as a structured constants and are typically
	      passed to functions provided by &prog_t; infrastructure
	      as parameters as is done here with
              <literal>OpenDialog()</literal>. 
            </para>
          </listitem>
          <listitem>
            <para><literal>`Label( message ),</literal></para>
            <para>
              Displaying strings in &lg; is done by means of
              <emphasis>Labels</emphasis>. This statement gets one parameter, the
              string variable we defined in the beginning. Because it is the
              first of two parameters passed to <literal>`VBox()</literal> this
              line is not terminated with a semicolon but with a comma. As in
              most programming languages commas are used to separate parameters
              in &lg;.
            </para>
          </listitem>
          <listitem>
            <para><literal>`PushButton("&amp;OK")</literal></para>
            <para>
              This statement displays a labeled push button. Since it is the
              next element in the enclosing <literal>`VBox()</literal>, it is
              displayed immediately below the preceding label. The &amp; in the
              label string is a &prog; feature declaring the subsequent character
              to be a key-shortcut. As a result the button can not only be
              clicked with the mouse but also be activated by typing
              <keycap>ALT</keycap>-<keycap>O</keycap>. 
            </para>
          </listitem>
          <listitem>
            <para><literal>)</literal> and <literal>);</literal></para>
            <para>
              The next two lines first close the open
              <literal>`VBox()</literal> and then the open
              <literal>OpenDialog()</literal>. Because
              <literal>`VBox()</literal> is passed as a parameter to
              <literal>OpenDialog()</literal> there is no need to terminate
              the statement with a semicolon. <literal>OpenDialog()</literal>
              on the other hand <emphasis>is</emphasis> a statement in the UI and
              hence <emphasis>must</emphasis> be terminated with a semicolon.
            </para>
          </listitem>
          <listitem>
            <para><literal>UI::UserInput();</literal></para>
            <para>
              Here we hand over control to the UI which then awaits some sort of
              user input. In this case it simply waits for the push button to be
              pressed by the user. Consequently our program blocks at this point
              until the user really does it.
            </para>
          </listitem>
          <listitem>
            <para><literal>UI::CloseDialog();</literal></para>
            <para>
              After all the UI-related action has finished, i.e. when
              <literal>UI::UserInput()</literal> returns, we want to remove the
              dialog we just created. This is done here.
            </para>
          </listitem>
          <listitem>
            <para><literal>}</literal></para>
            <para>
              Indicating the end of the block, the closing curly
              bracket ends our little &lg;-program.
            </para>
          </listitem>
        </itemizedlist>
      </section>
    
      <!-- ############################################################## -->

      <section id="id_ycp_first_ycpc">
        <title>The &lg_t; compiler</title>
        <para>
	  Section not written yet...
        </para>
      </section>
      
      <!-- ############################################################## -->

      <section id="id_ycp_first_start">
        <title>Running &lg_t;</title>
      
        <para>
          Now we can start the program using &prog_t;. For this, 
  	  we will use a script <literal>/sbin/yast2</literal>.
	  It is an envelope for easier setup of a running
	  &prog_t; environment.
        </para>

        <para>
          So if you are reading this document with a browser, you could
          copy-and-paste the program listed above into a file
          <literal>hello.ycp</literal>, and then run 
  	  <command>/sbin/yast2 hello.ycp</command> 
	  which should render the following
          <quote>spectacular</quote> result.
        </para>
      
        <figure id="id_ycp_first_startex">
          <title>Output of the <quote>Hello, World!</quote>-program</title>
          <mediaobject>
            <imageobject role="pdf">
              <!-- Formats OK: PNG -->
              <imagedata fileref="images/ycp/hello_00.png"
                align="center" scale="100"/>
            </imageobject>
            <imageobject role="html">
              <!-- Formats OK: PNG -->
              <imagedata fileref="images/ycp/hello_00.png"
                align="center" scale="100"/>
            </imageobject>
          </mediaobject>
        </figure>

        <para>
          Starting off with this simple example we will now explore the more
          subtle details of &lg;. Since all programming is about handling of data
          there must be a way to hold it in variables of different types. In the
          next section you will get to know the various data types that &lg;
          knows about.
        </para>
      </section>

    </chapter>

    <!-- ############################################################## -->

    <chapter id="id_ycp_data_types">
      <title>&lg_t; Data Types</title>

      <para>
        Just like any other high-level programming language YCP has
        typed variables to hold data of different kinds:
      </para>

      <itemizedlist>
        <listitem>
          <para>
            <xref linkend="id_ycp_data_void"/>
          </para>
        </listitem>
        <listitem>
          <para>
            <xref linkend="id_ycp_data_symbol"/>
          </para>
        </listitem>
        <listitem>
          <para>
            <xref linkend="id_ycp_data_boolean"/>
          </para>
        </listitem>
        <listitem>
          <para>
            <xref linkend="id_ycp_data_integer"/>
          </para>
        </listitem>
        <listitem>
          <para>
            <xref linkend="id_ycp_data_float"/>
          </para>
        </listitem>
        <listitem>
          <para>
            <xref linkend="id_ycp_data_string"/>
          </para>
        </listitem>
        <listitem>
          <para>
            <xref linkend="id_ycp_data_byteblock"/>
          </para>
        </listitem>
        <listitem>
          <para>
            <xref linkend="id_ycp_data_list"/>
          </para>
        </listitem>
        <listitem>
          <para>
            <xref linkend="id_ycp_data_map"/>
          </para>
        </listitem>
        <listitem>
          <para>
            <xref linkend="id_ycp_data_term"/>
          </para>
        </listitem>
        <listitem>
          <para>
            <xref linkend="id_ycp_data_path"/>
          </para>
        </listitem>
        <listitem>
          <para>
            <xref linkend="id_ycp_data_block"/>
          </para>
        </listitem>
        <listitem>
          <para>
            <xref linkend="id_ycp_data_symbol"/>
          </para>
        </listitem>
        <listitem>
          <para>
            <xref linkend="id_ycp_data_any"/>
          </para>
        </listitem>
      </itemizedlist>

      <!-- ############################################################## -->

      <section id="id_ycp_data_void" xreflabel="Data type void">
        <title>Data Type <emphasis>void (nil)</emphasis></title>
        <para>
          This is the most simple data type. It has only one possible value:
	  <literal>nil</literal>. Declaring variables of this type doesn't make
	  much sense but it is very useful to declare functions that need not
	  return any useful value. <literal>nil</literal> is often also
	  returned as an error flag if functions fail in doing their job
	  somehow.
        </para>
      </section>

      <!-- ############################################################## -->

      <section id="id_ycp_data_symbol" xreflabel="Data type symbol">
        <title>Data Type <emphasis>symbol</emphasis></title>
        <para>
          A symbol is a literal constant. It is denoted by a single 
	  backquote and a letter or underscore optionally followed by further letters, underscores or
          digits.
        </para>

        <example id="id_ycp_data_symbolex">
          <title>Symbol constants</title>
          <screen>`literal
`next</screen>
        </example>
      </section>

      <!-- ############################################################## -->

      <section id="id_ycp_data_boolean" xreflabel="Data type boolean">
        <title>Data Type <emphasis>boolean</emphasis></title>
        <para>
          In contrast to C/C++, a &lg; boolean is a real data type with the
          dedicated values <literal>true</literal> and
          <literal>false</literal>. Comparison operations like
          <literal>&lt;</literal> or <literal>==</literal> evaluate to a
          boolean value. The <literal>if (...)</literal> statement expects a
          boolean value as the result of the decision clause.
        </para>
      </section>

      <!-- ############################################################## -->

      <section id="id_ycp_data_integer" xreflabel="Data type integer">
        <title>Data Type <emphasis>integer</emphasis></title>
        <para>
          This is a machine independent signed integer value that is
          represented internally by a 64 bit value. The valid range is from
          <literal>-2^63</literal> through <literal>2^63-1</literal>. Integer
          constants are written just as you would expect. You can write them
          either decimal or hexadecimal by prefixing them with
          <literal>0x</literal>, or octal by prefixing them with
          <literal>0</literal> (just like in C/C++). 
        </para>

        <example id="id_ycp_data_integerex">
          <title>Integer constants</title>
          <screen>1
-17049349
0x9fa0
0xDEADBEEF
0233</screen>
        </example>
      </section>

      <!-- ############################################################## -->

      <section id="id_ycp_data_float" xreflabel="Data type float">
        <title>Data Type <emphasis>float</emphasis></title>
        <para>
          Floating point numbers. Because they are represented via the C
          datatype <literal>double</literal> the valid range is machine
          dependent. Constants are written just as you would expect. The
          decimal point is mandatory only if no exponent follows. Then there
          must be at least one digit leading the decimal point. The exponent
          symbol may be <literal>e</literal> or <literal>E</literal>.
        </para>

        <example id="id_ycp_data_floatex">
          <title>Float constants</title>
          <screen>1.0
-0.0035
1e30
-0.128e-17</screen>
        </example>
      </section>

      <!-- ############################################################## -->

      <section id="id_ycp_data_string" xreflabel="Data type string">
        <title>Data Type <emphasis>string</emphasis></title>
        <para>
          Represents a character string of almost arbitrary length (limited
          only by memory restrictions). String constants consist of UNICODE
          characters encoded in UTF8. They are enclosed in double quotes.
        </para>

        <para>
          The backslash in <emphasis>string</emphasis> can be used to mark
	  special characters:
	  <informaltable>
            <tgroup cols="2" align="left">
              <colspec colwidth="100" align="center"/>
              <colspec colwidth="300"/>
              <thead>
                <row>
                  <entry>Representation</entry>
                  <entry>Meaning</entry>
                </row>
              </thead>
              <tbody>
                <row valign="top">
                  <entry><literal>\n</literal></entry>
                  <entry>Newline (ASCII 10)</entry>
                </row>
                <row valign="top">
                  <entry><literal>\t</literal></entry>
                  <entry>Tabulator</entry>
                </row>
                <row valign="top">
                  <entry><literal>\r</literal></entry>
                  <entry>Carriage Return (ASCII 13)</entry>
                </row>
                <row valign="top">
                  <entry><literal>\b</literal></entry>
                  <entry>Backspace</entry>
                </row>
                <row valign="top">
                  <entry><literal>\f</literal></entry>
                  <entry>Form Feed</entry>
                </row>
                <row valign="top">
                  <entry><literal>\</literal><emphasis>abc</emphasis></entry>
                  <entry>
                    ASCII character represented by the octal value
                    <emphasis>abc</emphasis>. Note that unlike in C, there must
                    be exactly 3 octal digits!
                  </entry>
                </row>
                <row valign="top">
                  <entry><literal>\</literal><emphasis>X</emphasis></entry>
                  <entry>The character <emphasis>X</emphasis> itself.</entry>
                </row>
              </tbody>
            </tgroup>
	  </informaltable>
        </para>
        
        <para>
          A backslash followed by a newline makes both the backslash and the
          newline being ignored. Thus you can split a string constant over
          multiple lines in the &lg; code.
        </para>

        <example id="ycp_detail_stringconstantex">
          <title>String constants</title>
          <screen><quote>This string ends with a newline character.\n</quote>
<quote>This is also a newline: \012</quote></screen>
        </example>
      </section>

      <!-- ############################################################## -->

      <section id="id_ycp_data_byteblock" xreflabel="Data type byteblock">
        <title>Data Type <emphasis>byteblock</emphasis></title>
        <para>
          A byteblock simply is a sequence of zero or more bytes. The ASCII
          syntax for a byteblock is <literal>#[hexstring]</literal>. The
          <emphasis>hexstring</emphasis> is a sequence of hexadecimal values,
          lower and upper case letters are both allowed. A byte block
          consisting of the three bytes 1, 17 and 254 can thus be written as
          <literal>#[0111fE]</literal>.
        </para>
        <para>
          In most cases, however, you will not write a byteblock constant
	  directly into the &lg; code. You can use the SCR to read 
	  and write byteblocks.
        </para>

        <example id="id_ycp_data_byteblockex">
          <title>Byteblock constants</title>
          <screen>#[ ]
#[42]
#[0111fE]
#[03A6f298B5]</screen>
        </example>
      </section>

      <!-- ############################################################## -->

      <section id="id_ycp_data_list" xreflabel="Data type list">
        <title>Data Type <emphasis>list</emphasis></title>
        <para>
          A list is a finite sequence of values. These values need not
          necessarily have the same data type. List constants are denoted
          by square brackets. In contrast to C it is possible to use complex
          expressions as list members when defining a list constant. The
          empty list is denoted by <literal>[]</literal>.
        </para>

        <example id="id_ycp_data_listex">
          <title>List constants</title>
          <screen>[ ]
[ 1, 2, true ]
[ variable, 17 + 38, some_function(x, y) ]
[ "list", "of", "strings" ]</screen>
        </example>

        <para>
          Accessing the list elements is done by means of the index operator as
          in <literal>my_list[1]:"error"</literal>. The list elements are
          numbered starting with 0, so index 1 returns the second element.
          After the index operator there <emphasis>must</emphasis> be a colon
          denoting a following <emphasis>default value</emphasis> that is
          returned if the list access fails somehow. The default value should
          have the type that is expected for the current list access, in this
          case the string <quote>error</quote>.
        </para>
	<para>
	  Note 1: A list preserves order of its elements when iterating
	  over them.
	</para>
        <para>
          Note 2: There is also another method for accessing lists, originating
          from the early days of &prog;. The command <literal>select(my_list,
            1, "error")</literal> also returns the second element of
          <literal>my_list</literal>. While this still works, it is deprecated
          by now and may be dropped in the future.
        </para>
      </section>

      <!-- ############################################################## -->

      <section id="id_ycp_data_map" xreflabel="Data type map">
        <title>Data Type <emphasis>map</emphasis></title>
        <para>
          A &lg;-map is an associative array. It is a list of key-value-pairs
          with the keys being non-ambiguous, i.e. there are no two keys being
          exactly equal. While you can use values of any type for keys and
          values, you should restrict the <emphasis>keys</emphasis> to be of
          type <emphasis>string</emphasis> because from experience other types
          tend to complicate the code. <emphasis>Values</emphasis> of arbitrary
          type on the other hand make the map a very flexible data container.
          Maps are denoted with <literal>$[ key_0:value_0, key_1:value_1,
            ...]</literal>. The empty map is denoted by <literal>$[]</literal>.
        </para>
	<para>
	  Note: A map does not reserve order of its elements when iterating
	  over them.
	</para>

        <example id="id_ycp_data_mapex">
          <title>Map constants</title>
          <screen>$[ ]
$[ "/usr": 560, "/home" : 3200 ]
$[ "first": true, "2": [ true, false ], "number" : 8+9 ]</screen>
        </example>

        <para>
          Accessing the map elements is done by means of the index operator as
          in <literal>my_map["os_type"]:"linux"</literal>. This returns the
          value associated with the key <literal>"os_type"</literal>. As
          with lists, a default value <emphasis>must</emphasis> be appended
          (after a colon) that is returned if the given key does not
          exist. Again it should have the type that is expected for the
          current access, in this case the string <quote>linux</quote>.
        </para>
        <para>
          You may have noticed that the syntax for accessing maps kind of
          resembles that of accessing lists. This is due to the fact that lists
          are realized as maps internally with constant keys 0, 1, 2, and so
          on. 
        </para>
        <para>
          Note: There is also another method for accessing maps, originating
          from the early days of &prog;. The command <literal>lookup(my_map,
            "os_type", "linux")</literal> also returns the value associated
          with the given key. While this still works, it is deprecated by now
          and may be dropped in the future.
        </para>
      </section>

      <!-- ############################################################## -->

      <section id="id_ycp_data_path" xreflabel="Data type path">
        <title>Data Type <emphasis>path</emphasis></title>
        <para>
          A path is something special to &lg; and similar to paths in TCL. It
          is a sequence of path elements separated by dots. A path element can
          contain any characters except <literal>\x00</literal>. If it contains
          something else than <literal>a-zA-Z0-9_-</literal> it must be
          enclosed in double quotes. The <emphasis>root path</emphasis>, i.e.
          the root of the tree is denoted by a single dot. Paths can be used
          for multiple purposes. One of their main tasks is the selection of
          data from complex data structures like the SCR-tree (see <xref
            linkend="id_scr_tree"/>).
        </para>

        <para>
          The backslash in <emphasis>paths</emphasis> can be used to mark
	  a special characters:
	  <informaltable>
            <tgroup cols="2" align="left">
              <colspec colwidth="100" align="center"/>
              <colspec colwidth="300"/>
              <thead>
                <row>
                  <entry>Representation</entry>
                  <entry>Meaning</entry>
                </row>
              </thead>
              <tbody>
                <row valign="top">
                  <entry><literal>\n</literal></entry>
                  <entry>Newline (ASCII 10)</entry>
                </row>
                <row valign="top">
                  <entry><literal>\t</literal></entry>
                  <entry>Tabulator</entry>
                </row>
                <row valign="top">
                  <entry><literal>\r</literal></entry>
                  <entry>Carriage Return (ASCII 13)</entry>
                </row>
                <row valign="top">
                  <entry><literal>\b</literal></entry>
                  <entry>Backspace</entry>
                </row>
                <row valign="top">
                  <entry><literal>\f</literal></entry>
                  <entry>Form Feed</entry>
                </row>
                <row valign="top">
                  <entry><literal>\</literal><emphasis>xXX</emphasis></entry>
                  <entry>
                    ASCII character represented by the hexadecimal value
                    <emphasis>XX</emphasis>.
                  </entry>
                </row>
                <row valign="top">
                  <entry><literal>\</literal><emphasis>X</emphasis></entry>
                  <entry>The character <emphasis>X</emphasis> itself.</entry>
                </row>
              </tbody>
            </tgroup>
	  </informaltable>
        </para>

        <example id="id_ycp_data_pathex">
          <title>Path constants</title>
          <screen>.
.17
.etc.fstab
."\nHello !\n".World

."\xff" == ."\xFF"
."\x41" == ."A"
."" != .</screen>
        </example>
      </section>

      <!-- ############################################################## -->

      <section id="id_ycp_data_term" xreflabel="Data type term">
        <title>Data Type <emphasis>term</emphasis></title>
        <para>
          A term is something you won't find in <literal>C</literal>,
	  <literal>Perl</literal>, <literal>Pascal</literal> or
	  <literal>Lisp</literal> but you will find it in functional programming
	  languages like <literal>Prolog</literal> for
          example. It is a list plus a symbol, with the list written between
          normal brackets. The term <literal>`alpha(17, true)</literal> denotes
          a symbol <literal>`alpha</literal> and the list <literal>[ 17, true
            ]</literal> as <emphasis>parameters</emphasis> for that symbol.
          This looks pretty much like a function call.
        </para>
        <para>
          You can also use the term as a parameter in another function
          call, for example to specify a user dialog.
        </para>

        <example id="id_ycp_data_termex">
          <title>Term constants</title>
          <screen>`like_function_call(17, true)
`HBox(`Pushbutton(`Id(`ok), "OK"), `TextEntry(`Id(`name), "Name"))</screen>
        </example>
      </section>

      <!-- ############################################################## -->

      <section id="id_ycp_data_any" xreflabel="Data type any">
        <title>Data Type <emphasis>any</emphasis></title>
        <para>
          In the previous sections you have seen the data types &lg; knows
          about. In most cases you will (and should) assign a certain data type
          to every variable you declare. However, there might be cases when the
          type of a variable is not really clear at coding time, e.g. (in some
          rare cases) if you access the SCR to get some hardware data. While
          you should try very hard to avoid this situation, there might be
          cases where you can't. 
        </para>

        <para>
          To solve this problem, you may assign the type
          <emphasis>any</emphasis> to your variable which makes it accept
          assignments of any other valid type. However, because variables of
          type <emphasis>any</emphasis> are highly deprecated in &prog; by now,
          this <quote>feature</quote> will eventually be dropped in the near
          future. 
        </para>
      </section>

    </chapter>

    <!-- ############################################################## -->

    <chapter id="id_ycp_more_types">
      <title>More &lg_t; types</title>
      <para>
        Section not written yet...
      </para>

      <!-- ############################################################## -->

      <section id="id_ycp_data_block" xreflabel="Data type block">
        <title>Data Type <emphasis>block</emphasis></title>
        <para>
          Basically a block is a sequence of &lg; statements enclosed in curly
          brackets. It can be a whole &lg; program as was the case with the
          outermost block in <emphasis>hello.ycp</emphasis> from <xref
            linkend="id_ycp_hello"/>. What is special about blocks in &lg; is
          that they represent a value and therefore can be assigned to a
          variable. It is sometimes really useful to have those blocks as &lg;
          values because this makes it possible to use them as parameters to
          function calls. Of course the syntactical structure of blocks can
          become rather complex which leads to a description of the whole
          language itself. Therefore we put this into a section of its own:
          <xref linkend="id_ycp_progstruct"/>.
        </para>
        <para>
          For now the following examples should suffice.
        </para>

        <example id="id_ycp_data_blockex">
          <title>Block constants</title>
          <screen>{ return 17; }
{ integer a = 5; return a + 8; }</screen>
        </example>
      </section>

    </chapter>

    <!-- ############################################################## -->

    <chapter id="id_ycp_types">
      <title>&lg_t; Type System</title>
      <para>
        Section not written yet...
      </para>

      <!-- ############################################################## -->

      <section id="id_ycp_type_any" xreflabel="Data Type any And Type Checking">
        <title>Data Type <emphasis>any</emphasis> And Type Checking</title>
        <para>
          In <xref linkend="id_ycp_data_any"/> you have seen the data type
	  <literal>any</literal>. Because the value of type 
	  <literal>any</literal> can not be assigned to 
	  a variable of any other type. FIXME.
	  So it is important to check its type with <literal>is(...)</literal> and
          then re-assigning it to a variable of the correct type. The following
          example shows how this should be done.
        </para>

        <example id="id_ycp_type_anyex">
          <title>Type checking and data type <emphasis>any</emphasis></title>
          <screen width="80">
//
// Hypothetical example:
// ---------------------
// We don't know whether the SCR will return integers or floats...
//
any     any_var   = 0;
integer int_var   = 0;
float   float_var = 0.0;
boolean int_case  = false;

any_var = SCR::Read(...);

if ( is( any_var, integer ) )
{
   int_var  = any_var;
   int_case = true;
}
else if ( is( any_var, float ) )
{
   float_var = any_var;
   int_case  = false;
}
else
{
   // Error...
}

if ( int_case )
{
   // Use int_var...
}
else
{
   // Use float_var...
}
          </screen>
        </example>

        <para>
          As this is <emphasis>very</emphasis> cumbersome, you should try to
          avoid this oddity in any case. If it is ineluctable, do it as shown
          above to stay compatible with future &prog; behavior.
        </para>
      </section>
    </chapter>

    <!-- ############################################################## -->

    <chapter id="id_ycp_expeval" xreflabel="Expression evaluation">
      <title>&lg_t; Expression Evaluation</title>
      <para>
        From the interpreters point of view any &lg; value is an expression and
        thus can be evaluated. <emphasis>How</emphasis> the evaluation is done
        in a particular case depends on the data type of the expression.
      </para>
      <para>
        Because the <emphasis>block</emphasis> data type is somewhat special
        with respect to evaluation it will be explained first. The other basic
        data types will follow thereafter.
      </para>

      <!-- ############################################################## -->

      <section id="id_ycp_expeval_block" xreflabel="Evaluation of blocks">
        <title>Evaluation Of Blocks</title>
        <para>
          A &lg; <emphasis>block</emphasis> is a sequence of
          <emphasis>statements</emphasis> enclosed in curly brackets. Upon
          evaluation (execution), all the statements in the block are evaluated
          one by one. Because blocks are also a valid data type in &lg;, they
          can have a value (see <xref linkend="id_ycp_data_block"/>). If a
          block contains the special statement <literal>return(...)</literal>,
          then the returned value replaces the block upon evaluation.
        </para>
        <para>
          The following code sample shows a block with some statements.
        </para>
        <programlisting width="80">
{
   integer n = 1;

   while (n &lt;= 10)
   {
      y2milestone("Number: %1", n);
      n = n + 1;
   }

   y2milestone("Returned number: %1", n);

   return n;
}
        </programlisting>
        <para>
          It calculates the numbers 1 through 10 and prints these numbers into
	  the log file. The statement <literal>y2milestone(...)</literal> used
          for this is explained in <link linkend="yast2-logging">YaST2 Logging</link> along
	  with &lg;-logging as such. For now we are interested in the output
	  that is written to the log file. As can be seen below the loop is
	  executed 10 times and the counter has the value 11 after the loop.
	  Finally the last statement <literal>return(...)</literal> determines
	  the value of the whole block, in this case <literal>11</literal>.
        </para>
        <programlisting width="80">
...ycp/block_01.ycp:6 Number: 1
...ycp/block_01.ycp:6 Number: 2
...ycp/block_01.ycp:6 Number: 3
...ycp/block_01.ycp:6 Number: 4
...ycp/block_01.ycp:6 Number: 5
...ycp/block_01.ycp:6 Number: 6
...ycp/block_01.ycp:6 Number: 7
...ycp/block_01.ycp:6 Number: 8
...ycp/block_01.ycp:6 Number: 9
...ycp/block_01.ycp:6 Number: 10
...ycp/block_01.ycp:10 Returned number : 11
        </programlisting>
      </section>

      <!-- ############################################################## -->

      <section id="id_ycp_expeval_basic" xreflabel="Evaluation of basic data types">
        <title>Evaluation Of Basic Data Types</title>
        <para>
          The basic &lg; data types we got to know in <xref
            linkend="id_ycp_data_types"/> are evaluated in a rather straight
          forward way as will be shown in the following list.
        </para>
        <itemizedlist>
          <title>Evaluation of basic data types</title>
          <listitem>
            <para><emphasis>Simple data types</emphasis></para>
            <para>
              Most of the YCP data types can't be <quote>evaluated</quote> at
              all, as they simply evaluate to themselves. This holds for the
              simple types <literal>void</literal>, <literal>boolean</literal>,
              <literal>integer</literal>, <literal>float</literal>,
              <literal>string</literal>, <literal>symbol</literal> and
              <literal>path</literal>. 
            </para>
          </listitem>

          <listitem>
            <para><emphasis>list</emphasis></para>
            <para>
              When evaluating a list, the interpreter evaluates all the list
              elements thereby forming a new list.            
            </para>
            <programlisting width="80">
{
   list list_var = [ 1 + 1, true || false, "foo" + "bar" ];

   y2milestone("list_var: %1", list_var );
}
            </programlisting>
            <para>yields the log file entry</para>
            <programlisting width="80">
...ycp/list_eval.ycp:4 list_var: [2, true, "foobar"]
            </programlisting>
          </listitem>

          <listitem>
            <para><emphasis>map</emphasis></para>
            <para>
              A map is handled similar to a list. The values (but not the keys)
              are evaluated to form a new map. 
            </para>
            <programlisting width="80">
{
   map map_var = $[ "one" : `one, `two : "one" + "one" ];
   
   y2milestone("map_var: %1", map_var );
}
            </programlisting>
            <para>yields the log file entry</para>
            <programlisting width="80">
...ycp/map_eval.ycp:4 map_var: $["one":`one, `two:"oneone"]
            </programlisting>
          </listitem>

          <listitem>
            <para><emphasis>term</emphasis></para>
            <para>
              Upon evaluation, term parameters are evaluated
	      to form a new term.
            </para>
            <programlisting width="80">
{
   term term_var = `val ( 1 + 1, true || false, "foo" + "bar" );

   y2milestone("term_var: %1", term_var );
}
            </programlisting>
            <para>yields the log file entry</para>
            <programlisting width="80">
...ycp/term_eval.ycp:4 term_var: `val(2, true, "foobar")
            </programlisting>
          </listitem>
        </itemizedlist>

	<para>
	  All the evaluations we have seen above are closely related to
	  operators that may be used within an expression to act on the
	  variables. The next section will give an overview of the operators
	  that can be used in &lg;.
	</para>
      </section>
    </chapter>

    <!-- ############################################################## -->

    <chapter id="id_ycp_operators">
      <title>&lg_t; Operators</title>
      <para>
	As any other programming language &lg; knows a lot of operators that
	can be used to act on data. 
      </para>
  <section id="id_ycp_comparsion_operators">
    <title>Comparison Operators</title>
    <para>These are binary operators for comparison of two values. The
result is always boolean.</para>
    <informaltable>
      <tgroup cols="3">
        <thead>
          <row>
            <entry>Operator</entry>
            <entry>Datatype</entry>
            <entry>Description</entry>
          </row>
          <text/>
        </thead>
        <tbody>
          <row>
            <entry>==</entry>
            <entry>almost all</entry>
            <entry>True if operands are equal, otherwise false.</entry>
          </row>
          <text/>
          <row>
            <entry>&lt;</entry>
            <entry>almost all</entry>
            <entry>True if left operand is smaller than the right one, otherwise
false.</entry>
          </row>
          <text/>
          <row>
            <entry>&gt;</entry>
            <entry>almost all</entry>
            <entry>True if left operand is greater than the right one, otherwise
false.</entry>
          </row>
          <text/>
          <row>
            <entry>&lt;=</entry>
            <entry>almost all</entry>
            <entry>True if left operand is smaller or equal to the right one,
otherwise false.</entry>
          </row>
          <text/>
          <row>
            <entry>&gt;=</entry>
            <entry>almost all</entry>
            <entry>True if left operand is greater or equal to the right one,
otherwise false.</entry>
          </row>
          <text/>
          <row>
            <entry>!=</entry>
            <entry>almost all</entry>
            <entry>True if operands are not equal, otherwise false.</entry>
          </row>
          <text/>
        </tbody>
      </tgroup>
    </informaltable>
  </section>
  <section id="ycp_boolean_operators">
    <title>Boolean Operators</title>
    <para>These are logical operators, that works with boolean datatype,
two are binary one is unary. The result is always boolean.</para>
    <informaltable>
      <tgroup cols="3">
        <thead>
          <row>
            <entry>Operator</entry>
            <entry>Datatype</entry>
            <entry>Description</entry>
          </row>
          <text/>
        </thead>
        <tbody>
          <row>
            <entry>&amp;&amp;</entry>
            <entry>boolean</entry>
            <entry>True if both operands are true, otherwise false (logical
and).</entry>
          </row>
          <text/>
          <row>
            <entry>||</entry>
            <entry>boolean</entry>
            <entry>True if at least one of the operands is true, otherwise false
(logical or).</entry>
          </row>
          <text/>
          <row>
            <entry>!</entry>
            <entry>boolean</entry>
            <entry>True if the operand if false, otherwise false (logical
not).</entry>
          </row>
          <text/>
        </tbody>
      </tgroup>
    </informaltable>
    <para/>
  </section>
  <section id="ycp_bit_operators">
    <title>Bit Operators</title>
    <para>These are bit operators that works with integer, two are binary
one is unary. The result is always integer.</para>
    <informaltable>
      <tgroup cols="3">
        <thead>
          <row>
            <entry>Operator</entry>
            <entry>Datatype</entry>
            <entry>Description</entry>
          </row>
          <text/>
        </thead>
        <tbody>
          <row>
            <entry>&amp;</entry>
            <entry>integer</entry>
            <entry>Bits of the result number are product of the bits of the
operands (bit and).</entry>
          </row>
          <text/>
          <row>
            <entry>|</entry>
            <entry>integer</entry>
            <entry>Bits of the result number are count of the bits of the operands
(bit or).</entry>
          </row>
          <text/>
          <row>
            <entry>~</entry>
            <entry>integer</entry>
            <entry>Bits of the result number are reverted bits of operand (bit
not).</entry>
          </row>
          <text/>
          <row>
            <entry>&lt;&lt;</entry>
            <entry>integer</entry>
            <entry>Bits of the result number are left shifted bits of the operands
(bit shift left).</entry>
          </row>
          <text/>
          <row>
            <entry>&gt;&gt;</entry>
            <entry>integer</entry>
            <entry>Bits of the result number are right shifted bits of the
operands (bit shift right).</entry>
          </row>
          <text/>
        </tbody>
      </tgroup>
    </informaltable>
    <para/>
  </section>
  <section id="ycp_math_operators">
    <title>Math Operators</title>
    <para>There math operators works with numeric data types (integer and
float) and also with string. All are binary (except unary
minus).</para>
    <informaltable>
      <tgroup cols="3">
        <thead>
          <row>
            <entry>Operator</entry>
            <entry>Datatype</entry>
            <entry>Description</entry>
          </row>
          <text/>
        </thead>
        <tbody>
          <row>
            <entry>+</entry>
            <entry>integer, float, string</entry>
            <entry>The result is sum of the numbers or concatenation of the
strings.</entry>
          </row>
          <text/>
          <row>
            <entry>-</entry>
            <entry>integer, float</entry>
            <entry>The result is difference of the numbers.</entry>
          </row>
          <text/>
          <row>
            <entry>*</entry>
            <entry>integer, float</entry>
            <entry>The result is product of the numbers.</entry>
          </row>
          <text/>
          <row>
            <entry>/</entry>
            <entry>integer, float</entry>
            <entry>The result is quotient of the numbers (number class is
preserved, thus quotient of integers produce integer, etc).</entry>
          </row>
          <text/>
          <row>
            <entry>%</entry>
            <entry>integer</entry>
            <entry>The result is modulo.</entry>
          </row>
          <text/>
          <row>
            <entry>unary -</entry>
            <entry>integer, float</entry>
            <entry>The result is negative number.</entry>
          </row>
          <text/>
        </tbody>
      </tgroup>
    </informaltable>
    <para/>
  </section>
  <section id="ycp_triple_operators">
    <title>Triple Operator</title>
    <para>This is the operator known from C language ( <emphasis role="i">condition</emphasis>
<emphasis role="b">?</emphasis> <emphasis role="i">expression</emphasis> <emphasis role="b">:</emphasis> <emphasis role="i">expression</emphasis>). The first
operand is expression that can evaluate to boolean, types of second
and third operands are code dependent. The result of the triple
operator expression is the second operand in the case the first
operand (condition) evaluates to true, the third one otherwise.</para>
    <informaltable>
      <tgroup cols="3">
        <thead>
          <row>
            <entry>Code</entry>
            <entry>Result</entry>
            <entry>Comment</entry>
          </row>
          <text/>
        </thead>
        <tbody>
          <row>
            <entry>(3 &gt; 2) ? true : false</entry>
            <entry>true</entry>
            <entry>The expression (3 &gt; 2) evaluates to true, the result is
true</entry>
          </row>
          <text/>
          <row>
            <entry>contains ([1, 2, 3], 5) ? "yes" : "no"</entry>
            <entry>"no"</entry>
            <entry>The expression contains ([1, 2, 3], 5) evaluates to false, the
result is "no"</entry>
          </row>
          <text/>
          <row>
            <entry>(size ([]) &gt; 0) ? 1 : -1</entry>
            <entry>-1</entry>
            <entry>The expression size ([]) &gt; 0 evaluates to false, the result
is -1</entry>
          </row>
          <text/>
        </tbody>
      </tgroup>
    </informaltable>
    <note>
    <para>Using brackets makes code cleaner, but is not
necessary (according to operators precedence).</para>
</note>
<note>
    <para>With the introduction of the <link linkend="bracket">index operator</link> ( a = mapvar["key"]:default
), the sequence "]:" became a lexical token usable only for
indexing, so watch out when using the triple operator with lists
and maps. Use parentheses or white space.</para></note>
  </section>
  <section id="ycp_precedence_operators">
    <title>Operators Precedence</title>
    <para>The table of operators precedence (from lowest to highest).</para>
    <informaltable>
      <tgroup cols="2">
        <thead>
          <row>
            <entry>&#xA0;Direction&#xA0;</entry>
            <entry>&#xA0;Operators&#xA0;</entry>
          </row>
          <text/>
        </thead>
        <tbody>
          <row>
            <entry>right</entry>
            <entry>=</entry>
          </row>
          <text/>
          <row>
            <entry>left</entry>
            <entry>?:</entry>
          </row>
          <text/>
          <row>
            <entry>left</entry>
            <entry>||</entry>
          </row>
          <text/>
          <row>
            <entry>left</entry>
            <entry>&amp;&amp;</entry>
          </row>
          <text/>
          <row>
            <entry>left</entry>
            <entry>== !=</entry>
          </row>
          <text/>
          <row>
            <entry>left</entry>
            <entry>&lt; &lt;= &gt; &gt;=</entry>
          </row>
          <text/>
          <row>
            <entry>left</entry>
            <entry>+ -</entry>
          </row>
          <text/>
          <row>
            <entry>left</entry>
            <entry>* / %</entry>
          </row>
          <text/>
          <row>
            <entry>left</entry>
            <entry>&lt;&lt; &gt;&gt;</entry>
          </row>
          <text/>
          <row>
            <entry>left</entry>
            <entry>|</entry>
          </row>
          <text/>
          <row>
            <entry>left</entry>
            <entry>&amp;</entry>
          </row>
          <text/>
          <row>
            <entry>prefix</entry>
            <entry>! ~ -</entry>
          </row>
          <text/>
        </tbody>
      </tgroup>
    </informaltable>
  </section>

  <section id="bracket"><title>The bracket operator</title>
    <section id="bracket_intro"><title>Introduction</title>
      <para>
	The bracket operator is the use of '[' and ']' like accessing
	arrays in C.
      </para>

      <para>
	In YCP, this operator is used to ease handling with (possibly
	nested) lists and maps.</para>
      <para>
	The bracket operator can be applied to any list or map variable
	and should be used in favour of (deeply) nested lookup() and select()
	cascades.
      </para>
    </section>

    <section id="bracket_access"><title>Access variant</title>
      <para>
	The access variant of the bracket operator is used for accessing
	elements of a list or a map. It effectively replaces
	<literal>select</literal> for lists and <literal>lookup</literal>
	for maps.</para>

	<section id="bracket_access_lists"><title>Accessing lists</title>
	  <para>
	    General syntax:
	  </para>

	  <para>
	    for simple lists:
	  </para>

          <para>
	    &lt;<emphasis>list-var</emphasis>&gt;<literal>[</literal>&lt;<emphasis>index</emphasis>&gt;<literal>]:</literal>&lt;<emphasis>default-value</emphasis>&gt;
	  </para>

          <para>
	    for nested lists:
	  </para>

          <para>
            &lt;<emphasis>list-var</emphasis>&gt;<literal>[</literal>&lt;<emphasis>index</emphasis>&gt;<literal>,</literal>&lt;<emphasis>index</emphasis>&gt;<literal> &lt;</literal><emphasis>, ...</emphasis>&gt;<literal>]:</literal>&lt;<emphasis>default-value</emphasis>&gt;
          </para>

          <para>
	    <emphasis>index</emphasis> must be an integer and counts from
	    0 up to the number of elements-1.
	  </para>

          <para>
            It will return the <emphasis>default-value</emphasis> if you try
	    to access an out-of-bounds element.
	  </para>

          <important>
	    <para>
              Note that there must be no space between the closing bracket
	      and the colon.
            </para>
	  </important>

          <para>
            Examples:
	  </para>

          <para>
            <programlisting>{
    list list_of_numbers = [1, 2, 3];

    // value of element with index <emphasis>2</emphasis> is <literal>3</literal>
    integer three = list_of_numbers<literal>[</literal>2<literal>]:0</literal>;

    // evaluates to the default value <literal>0</literal>,
    // because list element with index <emphasis>42</emphasis> doesn't exist
    integer zero = list_of_numbers<literal>[</literal>42<literal>]:0</literal>;

    // evaluates to <literal>4</literal>
    integer number = [3, 4, 5][1]:8;

    list list_of_lists = [[1,2], [3,4], [5,6]];

    // list_of_lists[1] -> <literal>[3,4]</literal>
    // [3,4][0] -> <literal>3</literal>
    //
    // returns true because the left side evaluates to <literal>3</literal>
    // just as the right side does (three == <literal>3</literal>)
    return (list_of_lists<literal>[1</literal>,0<literal>]:0</literal> == three);
}
</programlisting>
	  </para>
	</section>

        <section id="bracket_access_maps"><title>Accessing maps</title>
	  <para>
	    General syntax:
	  </para>

          <para>
	    for simple maps:
	  </para>

          <para>
            &lt;<emphasis>map-var</emphasis>&gt;<literal>[</literal>&lt;<emphasis>key</emphasis>&gt;<literal>]:</literal>&lt;<emphasis>default-value</emphasis>&gt;
          </para>

          <para>
	    Examples:
	  </para>

          <programlisting>{
    // map with string as a key, integer as a value
    map simple_map = $["a":1, "b":2, "c":3];

    // evaluates to 3
    integer three = simple_map["c"]:0;

    // evaluates to 0
    integer zero = simple_map["notthere"]:0;
}</programlisting>

          <programlisting>{
    // map with string as a key, integer as a value
    // this example also defines the data-types
    map &lt;string, integer&gt; simple_map = $["a":1, "b":2, "c":3];

    // evaluates to 3
    integer three = simple_map["c"]:0;

    // evaluates to 0
    integer zero = simple_map["notthere"]:0;
}</programlisting>

          <para>
	    for nested lists:
	  </para>

          <para>
            &lt;<emphasis>map-var</emphasis>&gt;<literal>[</literal>&lt;<emphasis>key</emphasis>&gt;<literal>,</literal>&lt;<emphasis>key</emphasis>&gt;<literal> &lt;</literal><emphasis>, ...</emphasis>&gt;<literal>]:</literal>&lt;<emphasis>default-value</emphasis>&gt;
          </para>

          <para>
	    <emphasis>key</emphasis> must have an allowed type for maps,
	    integer, string, or symbol.
	  </para>

          <para>
            It will return <emphasis>default-value</emphasis> if you try
	    to access an non existing key.
	  </para>

          <important>
	    <para>
              Note that there must be no space between the closing bracket
	      and the colon.
            </para>
	  </important>

          <para>
	    Examples:
	  </para>

          <programlisting>{
    // map with string as a key and another map as a value
    map nested_map = $[
	"a":$[1:2],
	"b":$[3:4],
	"c":$[5:6]
    ];

    // nested_map["b"] -> $[3:4] ("b" is a key of the map)
    // $[3:4][3] -> 4            ( 3  is a key of the map)
    //
    // returns true
    return (nested_map["b",3]:0 == 4);
}</programlisting>

          <programlisting>{
    // map with string as a key and another map as a value
    // this map has a defined data-type
    map &lt;string, map &lt;integer, integer&gt; &gt; nested_map = $[
	"a":$[1:2],
	"b":$[3:4],
	"c":$[5:6]
    ];

    // returns true
    return (nested_map["b", 3]:0 == 4);
}</programlisting>
        </section>

	<section id="bracket_access_mixed"><title>Mixed map/list access</title>
	  <para>
	    Since the bracket operator applies to list and maps, you can use it
	    to access nested lists and maps. But be careful not to mix up the
	    index/key types.
	  </para>

	  <para>
	    Examples:
	  </para>

	  <para>
	    <programlisting>{
    map &lt;string, list &lt;integer&gt; &gt; map_of_lists = $[
	"a":[1, 2, 3, 4],
	"b":[5, 6],
	"c":[7, 8, 9]
    ];
    // evaluates to 3
    integer three = map_of_lists["a", 2]:0;

    list &lt;map &lt;integer, integer&gt; &gt; list_of_maps = [
	$[1:2],
	$[3:4],
	$[5:6]
    ];
    // returns true
    return (list_of_maps[1,0]:0 == three);
}</programlisting>
	  </para>
	</section>
      </section>

      <section id="bracket_assign">
        <title>Assign variant</title>

        <para>
          The bracket operator can also be used on the left side of
	  an assignment (lvalue). This changes the list or map element
	  <command>in place (!!)</command> and must be used with care.
	</para>

        <para>
          If the map or list element does not exist, it will be created.
	  The bracket operator can therefore replace <literal>add</literal>
	  and <literal>change</literal>.
	</para>

	<para>
          Creating a new list element will extend the size of the list.
	  Holes will be filled with <literal>nil</literal>. See the examples
	  below.
	</para>

        <para>
          If used as an lvalue, the default value is <command>not</command>
	  allowed.
	</para>

        <para>
          Examples:
	</para>

	<programlisting>{
    list numbers = [1, 2, 3];

    // changes the second element
    // numbers == [1, 25, 3] now
    numbers[1] = 25;

    // extends the list to 7 elements (0-6)
    // numbers == [1, 25, 3, nil, nil, nil, 6] now
    numbers[6] = 6;

    // remove an element item with index 2
    // numbers == [1, 25, nil, nil, nil, 6] now
    numbers = remove (numbers, 2);
}</programlisting>

	<programlisting>{
    map &lt;string, integer&gt; new_map = $["a":1, "b":2, "c":3];
    // changes the "c" element
    // new_map == $["a":1, "b":2, "c":42] now
    new_map["c"] = 42;

    // add a new element to m
    new_map["zz"] = 13;

    // remove an elment "a"
    // new_map == $["b":2, "c":42, "zz":13] now
    new_map = remove (new_map, "a");

    // returns $["b":2, "c":42, "zz":13]
    return (new_map);
}</programlisting>
      </section>
    </section>
  </chapter>

      <!-- ############################################################## -->

    <chapter id="id_ycp_data_locale" xreflabel="Data type locale">
        <title>Data Type <emphasis>locale</emphasis></title>
        <para>
          A string that is localized by YaST2 via the
          <emphasis>gettext</emphasis> mechanism (see gettext and ngettext in
          libc for more informations). Basically a string to be translated via
          gettext must be enclosed in <literal>_(...)</literal> which causes
          gettext to look up the translated string. It is even possible to
          distinguish singular and plural verbalizations depending on a
          parameter that denotes the actual number of something.
        </para>
        <para>
          For a simple number-independent string you write
          <literal>_(some_string_constant)</literal> which causes its
          translation.
        </para>
        <para>
          If the string to be translated needs to be different depending on the
          multiplicity of something then you write
          <literal>_(singular_string_constant1, plural_string_constant2,
            actual_number)</literal>. If <literal>actual_number</literal>
          equals 1 then the translation of the first string is used. Otherwise
          the translation of the second string is used.
        </para>
        <para>
          Note 1: There are languages that distinguish more than the two cases
          singular and plural. Principally gettext can handle even those cases
          as it allows more than two strings for selection, but that is beyond
          the scope of this document (see the gettext documentation).
        </para>
        <para>
          Note 2: It is not possible to put something other than string
          constants between the brackets.
        </para>

        <example id="id_ycp_data_localeex">
          <title>Locale constants</title>
          <screen>_("Everybody likes Linux!")
_("An error has occurred.", "Some errors have occurred", error_count)</screen>
        </example>
    </chapter>

    <!-- ############################################################## -->

    <chapter id="id_ycp_progstruct">
      <title>&lg_t; Program Structure</title>
      <para>
        Now that we have learned how data can be stored and evaluated in &lg;,
        we will take a look at the surrounding code structure that can be
        realized. Code structure is created by means of
        <emphasis>blocks</emphasis> and <emphasis>statements</emphasis>.
      </para>

      <!-- ############################################################## -->

      <section id="id_ycp_comment">
        <title>Comments</title>
        <para>
          Despite not being <quote>really</quote>
          <emphasis>statements</emphasis>, comments do (and should) belong to
          the overall structure of a &lg; program. There are two kinds of
          comments:
        </para>
        <itemizedlist>
          <listitem>
            <para><emphasis>Single-line comments</emphasis></para>
            <para>
              Single-line comments may start at any position on the line and
              reach up to the end of this line. They are introduced with
              <quote>//</quote>.
            </para>
          </listitem>
          <listitem>
            <para><emphasis>Multi-line comments</emphasis></para>
            <para>
              Multi-line comments may also start at any position on the line
              but they may end on another line below the starting line.
              Consequently there must be a start tag
              (<quote><literal>/*</literal></quote>) and an end tag
              (<quote><literal>*/</literal></quote>) as is shown below. 
            </para>
          </listitem>
        </itemizedlist>

        <example id="id_ycp_commentex">
          <title>Comments</title>
          <programlisting width="80">{
    // A single-line comment ends at the end of the line.

    /*
      Multi-line comments
      may span several lines.
    */

    y2milestone("This program runs without error");
}</programlisting>
        </example>
      </section>

      <!-- ############################################################## -->

      <section id="id_ycp_var_declare">
        <title>Variable Declaration</title>
        <para>
          Synopsis: <command>data_type</command> <emphasis>variable_name</emphasis>
          <command>=</command>
          <emphasis>initial_value</emphasis><command>;</command>
        </para>
        <para>
          Variable declarations in &lg; are similar to C. Before you can use a
          variable, you must declare it. With the declaration you appoint the
          new variable to be of a certain <emphasis>data_type</emphasis> which
          means you can assign only values of that specific type. To avoid any
          errors caused by uninitialized variables, a declaration
          <emphasis>must</emphasis> imply a suitable value assignment.
        </para>
        <para>
          Note: A variable declaration may occur at several points in the code
          which determines its validity (accessibility) in certain program
          regions (see <xref linkend="id_ycp_var_scope"/>).
        </para>

        <example id="id_ycp_var_declareex">
          <title>Variable Declaration</title>
          <programlisting width="80">{
    integer int_num     = 42;
    float   float_num   = 42.0;
    string  TipOfTheDay = "Linux is the best!";
    integer sum         = 4 * (int_num + 8);
}</programlisting>
        </example>
      </section>

      <!-- ############################################################## -->

      <section id="id_ycp_var_assign">
        <title>Variable Assignment</title>
        <para>
          Synopsis: <emphasis>variable_name</emphasis> <command>=</command>
          <emphasis>value</emphasis><command>;</command>
        </para>
        <para>
          An assignment statement is almost the same as a declaration
          statement. Just leave out the declaration. It is an error to assign a
          value to a variable that has not already been declared or to a
          variable of different data type.
        </para>

        <example id="id_ycp_var_assignex">
          <title>Variable Assignment</title>
          <programlisting width="80">{
    integer number = 0;

    number = number + 1;
    number = 2 * number;
    number = "Don't assign me to integers!";     // This will cause an error!!!
}</programlisting>
        </example>
      </section>

      <!-- ############################################################## -->

      <section id="id_ycp_conditional">
        <title>Conditional Branch</title>
        <para>
          Synopsis: <command>if
            (</command><emphasis>condition</emphasis><command>)</command>
          <emphasis>then_part</emphasis> [ <command>else</command>
          <emphasis>else_part</emphasis> ]
        </para>
        <para>
          Depending on <emphasis>condition</emphasis> only one of the code
          branches <emphasis>then_part</emphasis> and
          <emphasis>else_part</emphasis> is executed. The
          <emphasis>else_part</emphasis> is optional and may be omitted. Both
          <emphasis>then_part</emphasis> and 
          <emphasis>else_part</emphasis> may either be single statements or a
          sequence of statements enclosed in curly brackets, i.e. a block. The
          <emphasis>then_part</emphasis> is executed if and only if
          <emphasis>condition</emphasis> evaluates to <literal>true</literal>,
          the <emphasis>else_part</emphasis> otherwise. It is an error if
          <emphasis>condition</emphasis> evaluates to something other than
          <literal>true</literal> or <literal>false</literal>.
        </para>

        <example id="id_ycp_conditionalex">
          <title>Conditional branch</title>
          <programlisting width="80">{
    integer a = 10;

    if ( a &gt; 10 )
	y2milestone("a is greater than 10");
    else
    {
	// Multiple statements require a block...
	
	y2milestone("a is less than or equal to 10");
	a = a * 10;
    }
}</programlisting>
        </example>

	<example id="id_ycp_conditionalex2">
	  <title>Conditional branch with "<literal>else if</literal>"</title>
	  <programlisting width="80">{
    list &amp;string&amp; new_list = ["a", "new", "string"];

    if (contains(new_list, "test"))
	y2milestone("this is a test");

    else if (size(new_list) > 100)
	y2error("Too big list!");

    else if (contains(new_list, "string"))
	y2milestone("this is a new list");

    else
	y2error("Undefined behavior for list %1", new_list);
}</programlisting>
	</example>
      </section>

      <!-- ############################################################## -->

      <section id="id_ycp_while">
        <title><emphasis>while()</emphasis> Loop</title>
        <para>
          Synopsis: <command>while
            (</command><emphasis>condition</emphasis><command>)</command>
          <emphasis>loop_body</emphasis>
        </para>
        <para>
          The <command>while()</command> loop executes the attached
          <emphasis>loop_body</emphasis> again and again as long as
          <emphasis>condition</emphasis> evaluates to <literal>true</literal>.
          The <emphasis>loop_body</emphasis> may be either a single statement
          or a block of statements. 
        </para>
        <para>
          Because <emphasis>condition</emphasis> is checked at the top of
          <emphasis>loop_body</emphasis>, it may not be executed at all if
          <emphasis>condition</emphasis> is <literal>false</literal> right from
          start.
        </para>


        <example id="id_ycp_whileex">
          <title><emphasis>while()</emphasis> Loop</title>
          <programlisting width="80">{
    integer a = 0;

    while (a &lt; 10) a = a + 1;
 
    while (a &gt;= 0)
    {
	y2milestone("Current a: %1", a);
	a = a - 1;
    }
}</programlisting>
	</example>
      </section>

      <!-- ############################################################## -->

      <section id="id_ycp_dowhile">
	<title><emphasis>do..while()</emphasis> Loop</title>
	<para>
	  Synopsis: <command>do</command> <emphasis>loop_body</emphasis>
	  <command>while
	    (</command><emphasis>condition</emphasis><command>);</command>
	</para>
	<para>
	  The <command>do...while()</command> loop executes the attached
	  <emphasis>loop_body</emphasis> again and again as long as
	  <emphasis>condition</emphasis> evaluates to <literal>true</literal>.
	  The <emphasis>loop_body</emphasis> may be either a single statement
	  or a block of statements. 
	</para>
	<para>
	  Because <emphasis>condition</emphasis> is checked at the bottom of
	  <emphasis>loop_body</emphasis>, it is executed at least once, even if
	  <emphasis>condition</emphasis> is <literal>false</literal> right from
	  start.
	</para>

	<example id="id_ycp_dowhileex">
	  <title><emphasis>do...while()</emphasis> Loop</title>
	  <programlisting width="80">{
    integer a = 0;

    do
    {
	y2milestone("Current a: %1", a);
	a = a + 1;
    } while (a &lt;= 10);
}</programlisting>
	</example>
      </section>

      <!-- ############################################################## -->

      <section id="id_ycp_repeatuntil">
	<title><emphasis>repeat..until()</emphasis> Loop</title>
	<para>
	  Synopsis: <command>repeat</command> <emphasis>loop_body</emphasis>
	  <command>until
	    (</command><emphasis>condition</emphasis><command>);</command>
	</para>
	<para>
	  The <command>repeat...until()</command> loop executes the attached
	  <emphasis>loop_body</emphasis> again and again as long as
	  <emphasis>condition</emphasis> evaluates to <literal>false</literal>.
	  The <emphasis>loop_body</emphasis> may be either a single statement
	  or a block of statements. 
	</para>
	<para>
	  Because <emphasis>condition</emphasis> is checked at the bottom of
	  <emphasis>loop_body</emphasis>, it is executed at least once, even if
	  <emphasis>condition</emphasis> is <literal>true</literal> right from
	  start.
	</para>
	<para>
	  <command>repeat...until()</command> is similar to
	  <link linkend="id_ycp_dowhile"><command>do...while()</command></link>
	  except that <emphasis>condition</emphasis> is logically inverted.
	  The example below has been converted from the <link
	  linkend="id_ycp_dowhile"><command>do...while()</command></link>
          example.
        </para>

        <example id="id_ycp_repeatuntilex">
          <title><emphasis>repeat...until()</emphasis> Loop</title>
          <programlisting width="80">{
    integer a = 0;

    repeat 
    {
	y2milestone("Current a: %1", a);
	a = a + 1;
    } until (a &gt; 10);
}
	  </programlisting>
	</example>
      </section>

      <!-- ############################################################## -->

      <section id="id_ycp_break">
	<title><emphasis>break</emphasis> Statement</title>
	<para>
	  Synopsis: <command>break;</command>
	</para>
	<para>
	  The <command>break</command> statement is used within loops to exit
	  immediately. The execution is continued at the first statement after
	  the loop. 
        </para>

        <example id="id_ycp_breakex">
          <title><emphasis>break</emphasis> statement</title>
          <programlisting width="80">{
    integer a = 0;

    repeat 
    {
	y2milestone("Current a: %1", a);
	a = a + 1;
	if (a == 7) break;		// Exit the loop here, if a equals 7.
    } until (a &gt; 10);		// Value 10 will never be reached.

    y2milestone("Final a: %1", a);	// This prints 7.
}</programlisting>
        </example>

	<example id="id_ycp_breakex2">
	 <title>
	  <emphasis>break</emphasis> statement in
	  <emphasis>foreach</emphasis>
	 </title>
	 <programlisting width="80">{
    foreach (string text, ["a", "new", "string", "break"], {
	// finishes the foreach loop
	if (text == "string") break;
	
	// "string" and "break" will never get here
	y2milestone("Current text is '%1'", text);
    });
}</programlisting>
        </example>

	<example id="id_ycp_breakex3">
	    <title>
		Nice <emphasis>break</emphasis> statement in
		<emphasis>foreach</emphasis>
	    </title>
	    <programlisting width="80">{
    // list of found prime-number
    list &lt;integer&gt; found = [];
    // start with number
    integer number = 2;
    // finish with number
    integer max_number = 20000;
    
    while (number &lt; max_number) {
	boolean not_found = true;
	
	// try all already found numbers
	foreach (integer try, found, {
	    if (number % try == 0) {
		not_found = false;
		break;
	    }
	});
	
	if (not_found)
	    found = add (found, number);

	number = number + 1;
    }
    
    y2milestone("Sum:   %1", size(found));
    y2milestone("Found: %1", found);
}</programlisting>
	</example>

	<example id="id_ycp_breakex4">
	  <title>
	    <emphasis>break</emphasis> statement in
	    <emphasis>listmap</emphasis>
	  </title>
	  <programlisting width="80">{
    integer counter = 0;

    // goes through the list and returns a map
    // made of this list
    map new_map = listmap (string text,
        ["a", "new", "string", "break"], 
    {
        // finishes the listmap loop
        if (text == "string") break;

        counter = counter + 1;
	// returns one "key : value" pair of the new map
        return $[text : counter];
    });
    
    y2milestone("Returned map: %1", new_map);
}</programlisting>
	</example>
	
        <note>
	 <para id="usage_of_break_statement">
	  The <emphasis>break</emphasis> statement can be used for all loop
	  statments and also statments:
	  <link linkend="YCPBuiltinList_listmap">listmap</link>,
	  <link linkend="YCPBuiltinMap_mapmap">mapmap</link>,
	  list-based <link linkend="YCPBuiltinList_maplist">maplist</link>,
	  map-based <link linkend="YCPBuiltinMap_maplist">maplist</link>,
	  list-based <link linkend="YCPBuiltinList_foreach">foreach</link>,
	  map-based <link linkend="YCPBuiltinMap_foreach">foreach</link>,
	  list-based <link linkend="YCPBuiltinList_filter">filter</link>,
	  map-based <link linkend="YCPBuiltinMap_foreach">filter</link>.
	 </para>
	</note>
      </section>

      <!-- ############################################################## -->

      <section id="id_ycp_continue">
        <title><emphasis>continue</emphasis> Statement</title>
        <para>
          Synopsis: <command>continue;</command>
        </para>
        <para>
          The <command>continue</command> statement is used within loops to
          abandon the current loop cycle immediately. In contrast to
          <command>break</command> it doesnt exit the loop but jumps to the
          conditional clause that controls the loop. So for a
          <command>while()</command> loop, it jumps to the beginning of the
          loop and checks the condition. For a <command>do...while()</command>
          loop or <command>repeat...until()</command> loop, it jumps to the end
          of the loop end checks the condition.
        </para>

        <example id="id_ycp_continueex">
            <title>
		<emphasis>continue</emphasis> statement in
		<emphasis>while</emphasis>
	    </title>
            <programlisting width="80">{
    integer a = 0;

    while (a &lt; 10)
    {
	a = a + 1;
	if (a % 2 == 1) continue;     // % is the modulo operator.
	y2milestone("This is an even number: %1", a);
    }
}</programlisting>
        </example>
	
	<example id="id_ycp_continueex2">
	    <title>
		<emphasis>continue</emphasis> statement in
		<emphasis>foreach</emphasis>
	    </title>
	    <programlisting width="80">{
    // lists all files in /tmp directory
    map cmd = (map) SCR::Execute(.target.bash_output, "ls -1a /tmp");
    
    list &lt;string&gt; files = splitstring (
	(string) cmd["stdout"]:"", "\n"
    );
    
    <command>// clearing memory
    cmd = nil;</command>
    
    foreach (string filename, files, {
	if (regexpmatch(filename, "x")) {
	    y2warning("Filename '%1' contains 'x'", filename);
	}
	
	if (size(filename) > 20) {
	    y2error("Filename '%1' is longer than 20 chars", filename);
	    // we don't work with files with longer names
	    <command>continue;</command>
	}
	
	if (regexpmatch(filename, "^\.")) {
	    y2milestone("Filename '%1' starts with a dot", filename);
	} else {
	    y2milestone("Filename '%1' is what we are looking for", filename);
	}
    });
}</programlisting>
	</example>

	<example id="id_ycp_continueex3">
	    <title>
		<emphasis>continue</emphasis> statement in
		<emphasis>listmap</emphasis>
	    </title>
	    <programlisting width="80">{
    list &lt;integer&gt; random_integers = [];
    
    // filling up with random numbers
    while (size(random_integers) &lt; 10) {
	random_integers = add (random_integers, random(32768));
    }
    random_integers = toset(random_integers);
    
    map &lt;integer, integer&gt; new_map = listmap (integer number, random_integers, {
	// do not proccess huge numbers
	// actually, this finished the listmap and returns nil
	if (number > 32000) {
	    y2error("A huge number has been found");
	    continue;
	}
	
	if (number % 3 == 0) {
	    return $[number : number / 3];
	} else {
	    return $[number : number * 3];
	}
    });
    
    y2milestone("New map: %1", new_map);
}</programlisting>
	</example>
	
	<note>
	 The usage is similar to the <link
	 linkend="usage_of_break_statement">break</link>'s one.
	</note>
      </section>

      <!-- ############################################################## -->

      <section id="id_ycp_return">
        <title><emphasis>return</emphasis> Statement</title>
        <para>
          Synopsis: <command>return</command> [ <emphasis>return_value</emphasis>
          ]<command>;</command>
        </para>
        <para>
          The <command>return</command> statement immediately leaves 
	  the current function or a current top level block 
	  (that contains it) and optionally assigns a
          <emphasis>return_value</emphasis> to this block. If blocks are
          <emphasis>nested</emphasis>, i.e. if the current block is contained
          in another block, the return statement leaves all nested blocks and
          defines the value of the outermost block.
        </para>
        <para>
          However, if a block is used in an expression other than a block, and
          that expression is contained in an outer block, the
          <command>return</command> statement of the inner block won't leave
          the outer block but define the value of the inner block. This
          behavior is a as one would expect. For example
	  in the iteration builtins in <xref linkend="id_ycp_listmapapply"/>,
        </para>

        <example id="id_ycp_returnex">
            <title><emphasis>return</emphasis> statement 1</title>
            <programlisting width="80">{
    // This block evaluates to 42.
    return 42;

    y2milestone("This command will never be executed");
}</programlisting>
	</example>

	<example id="id_ycp_returnex2">
            <title><emphasis>return</emphasis> statement 2</title>
            <programlisting width="80">{
    // This block evaluates to 18
    while (true)
    {
	return 18;
    }
}</programlisting>
	</example>

	<example id="id_ycp_returnex3">
            <title><emphasis>return</emphasis> statement 3</title>
            <programlisting width="80">{
    // This program evaluates to 3:
    integer a = 1 + { return 2; };

    return a;
}</programlisting>
        </example>
      </section>

      <!-- ############################################################## -->

      <section id="id_ycp_function">
	<title>Function definition</title>
	<para>
	  Synopsis: <emphasis>data_type
	    function_name</emphasis> <command>(</command> [
	  <emphasis>typed_parameters</emphasis> ] <command>)</command>
	  <emphasis>function_body</emphasis>
	</para>
	<para>
	  A function definition creates a new function in
	  the current namespace named
	  <emphasis>function_name</emphasis> with a parameter list
	  <emphasis>typed_parameters</emphasis> that has
	  <emphasis>function_body</emphasis> attached for evaluation. The
	  <emphasis>function_body</emphasis> must return a value of type
	  <emphasis>data_type</emphasis> and the arguments passed upon function
	  call must match the type definitions in
	  <emphasis>typed_parameters</emphasis>. 
        </para>

        <example id="id_ycp_functionex">
          <title>Function definition</title>
          <programlisting width="80">{
    <command>void nothing()</command>
    {
	y2milestone("doing nothing, returning nothing");
    }

    <command>integer half( integer value )</command>
    {
	return value / 2;
    }

    <command>map &lt;string, integer&gt; get_some_map ()</command> {
	return listmap (string key, ["a", "b", "c"], {
	    return $[key : random(999)];
	});
    }

    // This renders: ...nothing: nil  -  half: 21...
    y2milestone("nothing: %1  -  half: %2", <command>nothing()</command>, <command>half(42)</command> );
    
    // This renders something like: new half-random map: $["a":839, "b":393, "c":782]
    y2milestone("new half-random map: %1", <command>get_some_map()</command>);
}</programlisting>
	</example>
      </section>

      <!-- ############################################################## -->

      <section id="id_ycp_function_declaration">
	<title>Function declaration</title>
	<para>
	  Synopsis: <emphasis>data_type
	    function_name</emphasis> <command>(</command> [
	  <emphasis>typed_parameters</emphasis> ] <command>);</command>
	</para>
	<para>
	  A function declaration allows you to declare
	  only a header of a function without its body.
	  It's main purpose is for indirect recursion etc.
	  You have to provide a function definition with
	  exactly the same arguments later in the same file.
	  A new function will be declared in
	  the current namespace named
	  <emphasis>function_name</emphasis> with a parameter list
	  <emphasis>typed_parameters</emphasis>. 
        </para>

        <example id="id_ycp_function_declarationex">
          <title>Function declaration</title>
          <programlisting width="80">{
    // declares the function - it is defined later
    <command>void nothing();</command>

    integer half( integer value )
    {
	return value / 2;
    }

    // This renders: ...nothing: nil  -  half: 21...
    // uses the function <command>nothing</command>
    y2milestone("nothing: %1  -  half: %2", <command>nothing()</command>, half(42) );

    // defines the function
    <command>void nothing()</command>
    {
	y2milestone("doing nothing, returning nothing");
    }
}</programlisting>
	</example>
      </section>

      <!-- ############################################################## -->

      <section id="id_ycp_include">
	<title><emphasis>include</emphasis> Statement</title>
	<para>
	  Synopsis: <command>include "</command> 
	  <emphasis>included file</emphasis><command>";</command>
	</para>
	<para>
	  The include statement allows you to insert
	  contents of a file at the given place in 
	  the current file. If the current file is a module,
	  the contents of the included file will become
	  a part of the module.
        </para>
	<para>
	  This is useful for dividing a large file into
	  number of pieces. However, if a file is included
	  more than once in a single block, the 2nd, 3rd
	  etc. include statements are ignored.
	</para>
	<para>
	  The <emphasis>included file</emphasis> can be
	  a relative or an absolute file name. Relative 
	  names are looked up with <filename>/usr/share/YaST2/include</filename>
	  as a base. 
	</para>

        <example id="id_ycp_includeex">
          <title>Include a file</title>
          <programlisting width="80">// this will include /usr/share/YaST2/include/program/definitions.ycp

include "program/definitions.ycp";</programlisting>
	</example>
      </section>

      <!-- ############################################################## -->

      <section id="id_ycp_import">
	<title><emphasis>import</emphasis> Statement</title>
	<para>
	  Synopsis: <command>import </command> 
	  "<emphasis>name_space</emphasis><command>";</command>
	</para>
	<para>
	 The import statement allows you to import another namespace (module)
	 into the one you are just running in. Then you can access the global
	 functions and variables of that namespace using the double-colon.
	</para>
	<para>
	 Namespaces, to be imported, are looked up in the
	 <filename>/usr/share/YaST2/modules/</filename> directory.
	</para>
	<programlisting>{
    import "<command>Hostname</command>";
    import "<command>IP</command>";
    
    // writes: Check FQDN: true
    y2milestone("Check FQDN: %1", <command>Hostname</command>::Check("www.example.com"));

    // writes: Check IP4: false
    y2milestone("Check IP: %1", <command>IP</command>::Check4("192.168.0.356"));
    
}</programlisting>
	<para>
	 This is often used for clients using some global API of modules but
	 also for modules using global API of another ones. Please, be careful
	 on creating cross-dependencies when creating an RPM package from
	 sources.
	</para>
      </section>

      <!-- ############################################################## -->

      <section id="id_ycp_var_scope">
	<title>Variable Scopes and blocks</title>
	<para>
	  In contrast to many other programming languages, &lg; variables can
	  be defined at (almost) any point in the code, namely between other
	  statements. Given that, there must be some rules regarding the
	  creation, destruction and validity of variables. Generally variables
	  are valid (accessible) within the block they are declared in. This
	  also covers nested blocks that may exist in this current block. The
	  valid program region for a variable is called a
	  <emphasis>scope</emphasis>.
	</para>

        <example id="id_ycp_var_scopeex">
          <title>Variable scopes and blocks</title>
          <programlisting width="80">{
    // Declared in the outer block
    integer outer = 42;

    {
	// Declared in the inner block
	integer inner = 84;

	// This is OK.
	// Log: ...IN: inner: 84 - outer: 42
	y2milestone("IN: inner: %1 - outer: %2", inner, outer);
    }

    // This yields an error because "inner" is not defined any more.
    y2milestone("OUT: inner: %1 - outer: %2", inner, outer);
}</programlisting>
	</example>
      </section>


      <!-- ############################################################## -->

      <section id="id_ycp_listmapapply">
        <title>Applying Expressions To Lists And Maps</title>
        <para>
	  Additionally to the structural language elements described so far,
	  there are special commands that apply to <literal>lists</literal> and
	  <literal>maps</literal>. What is special about these commands is that
	  they apply an expression to the single elements of a list or
	  map. This is done in a <emphasis>functional</emphasis> manner,
	  i.e. the expression to be applied is passed as a parameter. Generally
	  this executes faster than a <emphasis>procedural</emphasis> loop
	  because the internal functionality is realized in a very effective
	  way.
	</para>
	<para>
	  Furthermore some of these commands create lists from maps, maps from
	  maps, maps from lists etc., so that they can be used to avoid the
	  cumbersome assembling of these compound data types in a
	  <emphasis>procedural</emphasis> loop.
	</para>

	<!-- ############################################################## -->

	<section id="id_ycp_foreach">
	  <title><emphasis>foreach()</emphasis> Statement</title>
	  <para>
	    Synopsis (list): <literal>any</literal> <command>foreach (</command>
	    <emphasis>type variable, list&lt;type&gt;, { expression }</emphasis>
	    <command>);</command>
	  </para>
	  <para>
	    Synopsis (map): <literal>any</literal> <command>foreach(</command>
	    <emphasis>type_key variable_key, type_value variable_value, 
	      map&lt;type_key, type_value&gt;, { expression }</emphasis>
	    <command>);</command>
	  </para>
	  <para>
	    This statement is a means to process the content of
	    <emphasis>list</emphasis> or <emphasis>map</emphasis> in a
	    sequential manner. It establishes an implicit loop over all entries
	    of the list or map thereby executing the given
	    <emphasis>expression</emphasis> with the respective entries. With
	    lists the <emphasis>variable</emphasis> is a placeholder for the
	    current entry. With maps, <emphasis>variable_key</emphasis> and
	    <emphasis>variable_value</emphasis> are substituted for the respective
	    key-value-pair.
	  </para>
	  <!--
	  <para>
	    Note 1: FIXME: Typing 
	  </para>
	  -->

	  <note>
	    <para>
	      The return value of the last execution of
	      <emphasis>expression</emphasis> determines the value of the whole
	      <command>foreach()</command> statement.
	    </para>
	  </note>

	  <example id="id_ycp_foreachex">
	    <title><emphasis>foreach()</emphasis> Loop</title>
	    <programlisting width="80">{
    // Exemplary <emphasis>foreach</emphasis> for list
    // This yields 3
    foreach(integer value, [1, 2, 3], { return value; });

    // Exemplary <emphasis>foreach</emphasis> for map
    // This yields 9
    foreach(integer key, integer value, $[1:1, 2:4, 3:9], {
	    y2milestone("value: %1", value);
	    return value;
    });
}</programlisting>
	  </example>
	  
	  <example id="id_ycp_foreachex2">
	    <title>Sophisticated <emphasis>foreach()</emphasis> Loop</title>
	    <programlisting width="80">{
    list &lt;string&gt; codes = ["X1", "D", "vT", "o", "T5h8"];
    
    list &lt;string&gt; one_letter_codes = [];
    list &lt;string&gt; other_codes = [];
    
    <command>foreach (</command><emphasis>string</emphasis> code, codes, {
	// all one-letter codes
	if (size(code) == 1) {
	    one_letter_codes = add (one_letter_codes, code);
	// other ones
	} else {
	    other_codes = add (other_codes, code);
	}
    }<command>)</command>;
    
    // Results in: ["D", "o"]
    y2milestone("One-letter codes: %1", one_letter_codes);
    
    // Results in: ["X1", "vT", "T5h8"]
    y2milestone("Other codes: %1", other_codes);
}</programlisting>
	  </example>
	</section>

	<!-- ############################################################## -->

	<section id="id_ycp_listmap">
	  <title><emphasis>listmap()</emphasis> Statement</title>
	  <para>
	    Synopsis: <literal>map&lt;type1, type2&gt;</literal> <command>listmap(</command>
	    <emphasis>type3 variable, list&lt;type3&gt;, { expression returning 
	    map&lt;type1, type2&gt; }</emphasis>
	    <command>);</command>
	  </para>
	  <para>
	    This statement is a means to process the content of
	    <emphasis>list</emphasis> in a sequential manner. It establishes an
	    implicit loop over all entries in <emphasis>list</emphasis> thereby
	    executing the given <emphasis>expression</emphasis> with the
	    respective entry. During execution <emphasis>variable</emphasis> is a
	    placeholder for the current entry. For each element in
	    <emphasis>list</emphasis> the expression is evaluated in a new
	    context. The result of each evaluation MUST be a map
	    with a single pair of key-value. All the returned key-value-pairs
	    are assembled to form the new map that is returned.
	  </para>
	  <!--
	  <para>
	    Note: FIXME: Typing, break, continue 
	  </para>
	  -->

	  <example id="id_ycp_listmapex">
            <title><emphasis>listmap()</emphasis> statement</title>
            <programlisting width="80">{
    // This results in $[1:"xy", 2:"xy", 3:"xy"]
    map &lt;integer, string&gt; m1 = listmap (integer s, [1, 2, 3], {
	return $[s: "xy"]
    });

    // This results in $[11:2, 12:4, 13:6]
    map &lt;integer, integer&gt; m2 = listmap (integer s, [1, 2, 3], {
	integer a = s+10;
        integer b = s*2;
	list ret = [a, b];
        return ret;
    });

    y2milestone("map 1: %1  - map 2: %2", m1, m2);
}</programlisting>
	  </example>
	</section>

	<!-- ############################################################## -->

	<section id="id_ycp_maplist">
	  <title><emphasis>maplist()</emphasis> Statement</title>
	  <para>
	    Synopsis (map): <literal>list&lt;type1&gt;</literal> <command>maplist(</command>
	    <emphasis>type2 key, type3 value, map&lt;type2, type3&gt;, 
	    { block returning type1 }</emphasis>
	    <command>);</command>
	  </para>
	  <para>
	    Synopsis (list): <literal>list&lt;type1&gt;</literal>
	    <command>maplist(</command>
	    <emphasis>type2 variable, list&lt;type2&gt;, 
	    { block returning type1 }</emphasis>
	    <command>);</command>
	  </para>
	  <para>
	    This statement is a means to process the content of
	    <emphasis>map</emphasis> or <emphasis>list</emphasis> in a
	    sequential manner. It establishes an implicit loop over all entries
	    in <emphasis>map</emphasis> or <emphasis>list</emphasis> thereby
	    executing the given <emphasis>expression</emphasis> with the
	    respective entries. With lists the <emphasis>variable</emphasis> is a
	    placeholder for the current entry. With maps,
	    <emphasis>key</emphasis> and <emphasis>value</emphasis> are
	    substituted for the respective key-value-pair. For each element the
	    expression is evaluated in a new context.  All return values are
	    assembled to form the new list that is returned.
	  </para>

	  <note>
	    <para>
	      To exit the loop before it ends, use the
	      <command>break</command>. See the usage in the
	      <link linkend="id_ycp_break">break statement description</link>.
	    </para>
	    
	    <para>
	      To skip to the next loop step, use the
	      <command>continue</command>. See the usage in the
	      <link linkend="id_ycp_continue">continue statement
	      description</link>.
	    </para>
	  </note>

	  <example id="id_ycp_maplistex">
            <title><emphasis>maplist()</emphasis> statement</title>
            <programlisting width="80">{
    // This results in [2, 4, 6]
    list&lt;integer&gt; l1 = maplist (integer s, [1, 2, 3], {
	reuturn s*2;
    });

    // This results in [2, 6, 12]
    list&lt;integer&gt; l2 = maplist (integer k, integer v, $[1:2, 2:3, 3:4], {
	return k*v;
    });

    y2milestone("list 1: %1  - list 2: %2", l1, l2);
}</programlisting>
	  </example>
	</section>

	<!-- ############################################################## -->

	<section id="id_ycp_mapmap">
	  <title><emphasis>mapmap()</emphasis> Statement</title>
	  <para>
	    Synopsis: <literal>map&lt;type1, type2&gt;</literal> <command>mapmap(</command>
	    <emphasis>type3 key, type4 value, map&lt;type3, type4&gt;, 
	    { expression returning map&lt;type1, type2&gt; }</emphasis>
	    <command>);</command>
	  </para>
	  <para>
	    This statement is a means to process the content of
	    <emphasis>map</emphasis> in a sequential manner. It establishes an
	    implicit loop over all entries in <emphasis>map</emphasis> thereby
	    executing the given <emphasis>expression</emphasis> with
	    <emphasis>key</emphasis> and <emphasis>value</emphasis> substituted
	    for the respective key-value-pair. For each map element the
	    expression is evaluated in a new context. The result of each
	    evaluation MUST be a map
	    with a single pair of key-value. All the returned key-value-pairs are assembled to form the new map
	    that is returned.
	  </para>

	  <example id="id_ycp_mapmapex">
            <title><emphasis>mapmap()</emphasis> statement</title>
            <programlisting width="80">{
    // This results in $[11:"ax", 12:"bx"]
    map&lt;integer,string&gt; m = mapmap (integer k, string v, $[1:"a", 2:"b"], {
	return [k+10, v+"x"];
    });

    y2milestone("map: %1", m);
}
            </programlisting>
	  </example>
	</section>
      </section>
    </chapter>



    <!-- ############################################################## -->

    <chapter id="id_ycp_ui">
      <title>Controlling The User Interface</title>
      <para>
	In the previous sections we have already seen some &lg; code that
	dealt with the creation and handling of on-screen dialogs. These
	examples were rather simple to show the <emphasis>basic</emphasis>
	strategy of creating dialogs. Of course designing <quote>real</quote>
	dialogs that do useful things is is bit more complicated and requires a
	rather good knowledge of the instruments provided by the UI.
      </para>
      <para>
	Because the UI has been designed to be most flexible, the possibilities
	for creating and managing dialogs are quite versatile. Consequently the
	instruments for doing this are rather diverse. In fact the UI extends
	the basic &lg; language to a large extent, thereby providing the means
	to create and manage on-screen dialogs.
      </para>
      <para>For more information about the User Interface, handling events see
          the <link linkend="layout-howto">Layout HOWTO</link>.
      </para>
    </chapter>
    
    <!-- ############################################################## -->
    
    <chapter id="id_ycp_wizard">
      <title>The &prog_t; Wizard</title>
      <para>
	In the previous section the basic mechanisms suitable for managing
	on-screen dialogs were presented. However, creating dialogs for each and
	every application from scratch would be cumbersome and moreover is
	unnecessary. For example the well-known layout that is presented with
	nearly every &prog; dialog during installation was not
	<emphasis>programmed</emphasis> anew for each dialog. Rather it is kind
	of imported from a special &lg; module, the <emphasis>Wizard</emphasis>
	that provides all the functionality necessary to create uniform
	dialogs.
      </para>
      <para>
	Furthermore, as time went by, during the development of the &prog;
	installer, the developers encountered situations where the same (or
	similar) tasks ofttimes had to be accomplished at different locations
	in the overall program flow. For example opening a popup to ask the
	user a question with the predefined buttons <quote>Yes</quote> and
	<quote>No</quote> is a procedure used very often.
      </para>
      <para>
	This led to the development of predefined dialog elements that can (and
	should) be included in the current &lg; source. Displaying the
	Yes-No-popup from the example above is then reduced to calling a
	function with respective parameters. Aside from avoiding the need to
	redevelop such things again and again, another benefit is the ever same
	visual appearance that adds up to the well-known &prog; look-and-feel.
	Meanwhile there are also many functions that are not UI-related but
	nonetheless very useful.
      </para>
      <para>
	The omnium gatherum of all these elements has been collected to form
	the so-called <quote>&prog; Wizard</quote>. In short the &prog; Wizard
	consists of one &lg; module that provides the layout framework used in
	the installation dialogs and some additional &lg; modules that provide
	access to several common dialog elements needed rather often. Many
	<quote>generic</quote> functions are at hand as well.
      </para>
      <para>
	The following two sections cover these topics mostly by means of
	references to the &prog; developers documentation.
      </para>
    </chapter>

    <chapter id="id_ycp_y2base_alone">
    <title>Running <command>y2base</command> Stand-Alone</title>

    <para>
      In the previous section you got to know how to do a 
      &prog_t; program. Well, normally &lg_t;-scripts are
      executed involving the whole &prog;-machinery, e.g. during
      installation, which requires correct embedding of the script into the
      surrounding &lg; environment. Fortunately there is a way to let run
      &lg;-scripts isolated, i.e. stand-alone.
    </para>
      <para>
        To do so we make use of the architectural separation of components
        featured by &prog;. The <quote>command line version</quote> of &prog;
        is called <command>y2base</command> and can usually be found in
        <literal>/usr/lib/YaST2/bin</literal>. You could set the
        <literal>PATH</literal> to include this location to avoid typing in the
        full path every time.
      </para>
      <beginpage/>
      <screen width="100">$&gt; y2base -h

Usage: y2base [LogOpts] Client [ClientOpts] Server [Generic ServerOpts] [Specific ServerOpts]
LogOptions are:
    -l | --logfile LogFile    : Set logfile
ClientOptions are:
    -s                        : Get options as one YCPList from stdin
    -f FileName               : Get YCPValue(s) from file
    '(any YCPValue)'          : Parameter _IS_ a YCPValue
Generic ServerOptions are:
    -p FileName               : Evaluate YCPValue(s) from file (preload)
    '(any YCPValue)'          : Parameter _IS_ a YCPValue to be evaluated
Specific ServerOptions are any options passed on unevaluated.

Examples:
y2base installation qt
    Start binary y2base with intallation.ycp as client and qt as server
y2base installation '("test")' qt
    Provide YCPValue '"test"' as parameter for client installation
y2base installation qt -geometry 800x600
    Provide geometry information as specific server options</screen>

      <para>
        This help page, showing the possible options in a call of
        <command>y2base</command>, is rather self-explaining. For the moment
        the interesting parameters are <emphasis>Client</emphasis> and
        <emphasis>Server</emphasis>. In <xref
          linkend="id_big_external_program"/> we learned that &prog; consists
        of several modules, some of them being
        <emphasis>client-components</emphasis> and some others being
        <emphasis>server-components</emphasis>. By invoking &prog; in the way
        displayed above we can connect any client-component with any
        server-component.
      </para>
      <para>
        Because a &lg;-program (also called &lg;-module) can act as a
        client-component, it is possible to connect it with a server-component
        suitable of executing it. Since our <quote>Hello,
          World!</quote>-program displays something on screen, we need to use
        the UI as server-component in this case. As already said the UI is able
        to use a text-based console environment as well as a graphical X11
        environment which leads to the following two methods of running a
        &lg;-script.  
      </para>

      <itemizedlist>
        <listitem>
          <para><command>y2base file.ycp qt</command></para>
          <para>
            This will execute <literal>file.ycp</literal> in the graphical
            Qt-UI.
          </para>
        </listitem>
        <listitem>
          <para><command>y2base file.ycp ncurses</command></para>
          <para>
            This will execute <literal>file.ycp</literal> in the text-based
            NCurses-UI.
          </para>
        </listitem>
      </itemizedlist>
    </chapter>
  </book>

<!-- ====== Allow emacs psgml to parse the document hierarchy ====== -->
<!-- ATTENTION * This MUST be at the end of the document * ATTENTION -->
<!--
Local Variables:
sgml-parent-document: ("yast_intro.xml")
End:
-->
<!-- ====== Allow emacs psgml to parse the document hierarchy ====== -->
