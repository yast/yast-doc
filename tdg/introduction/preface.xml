<?xml version="1.0" encoding='ISO-8859-1'?>
<!-- =============================================================== -->
<!--
File         : preface.xml
Author       : Thomas Rölz 
Initial date : 2002/10/23
CVS          : $Id: preface.xml 164 2006-06-26 14:25:31Z locilka $
-->
<!-- =============================================================== -->


  <book id="Book-Preface">
    <bookinfo>
	<title>Preface</title>
    </bookinfo>
    
    <chapter id="id_preface_intro">
    <title>Intro</title>
    <para>The most important thing reads: <citation>DON'T PANIC!</citation></para>
    
    <para>
      Administering a Linux system at the lowest level is sometimes not an easy
      task. If it should be done manually, it requires a very experienced and
      knowledgeable person, willing to browse and edit very many configuration
      files. As a result there have been many efforts to create intelligent
      tools that provide rather automatic means to accomplish this challenging
      and (at the same time) tedious task. 
    </para>
    <para>
      One of these tools is &prog;, the &lx; installer. Being the result of a
      rather long period of development, it is by now a very large and capable
      system, well suited to install and administer a &lx; system. While the
      internal functionality of &prog; is quite multifaceted and therefore not
      exactly easy to understand, it should not be kept as a secret. Rather the
      world shall be encouraged to make use of the mechanisms &prog; can
      provide. 
    </para>
    <para>
      This goal can be achieved because &prog; is not a closed monolithic
      system but has a high degree of modularity. In fact it consists largely
      of modules that could as well be created by people not related to &prog;
      development. For example hardware vendors could provide a &prog; module
      for customizing specific system settings related to their particular
      piece of hardware. From the user's point of view this would be much more
      comfortable than editing configuration files by hand. 
    </para>
    <para>
      Of course this can't be done without some knowledge of the &prog;
      internal functionality. So this document tries to lighten things up by
      advancing from the unsubtle connections in the beginning to more and more
      detailed explanations towards the end. However, describing the
      particularities of this matter in full detail would easily fill several
      heavy books which in turn would contradict the goal of introductory
      simplification. Furthermore some of these <quote>details</quote> are
      subject to moderate change service, which would render
      <quote>static</quote> documentation like this one outdated rather
      quickly.
    </para>
    <para>
      To alleviate these problems, this text very often refers to the
      <quote>official</quote> &prog; developers documentation that can be found
      in <literal>/usr/share/doc/packages/yast2*</literal> (especially towards
      the end). Aside from the references to be found in the following text,
      this location provides very valuable information regarding the whole
      &prog; environment. To have access to these files the following packages
      must be installed:
    </para>

    <itemizedlist>
      <listitem><para>yast2-devel</para></listitem>
      <listitem><para>yast2-core-devel</para></listitem>
      <listitem><para>liby2util-devel</para></listitem>
      <listitem><para>yast2-packagemanager-devel</para></listitem>
    </itemizedlist>

    <!--
    FIXME: still no PDF available
    <note>
      <para>
	This document is available in HTML and PDF. However, the primary target
	format is HTML because of the many references to the &prog; developers
	documentation. When viewed with a web browser these links are
	functional and provide easy access to the respective files.
	Unfortunately in the PDF format the links are <emphasis>not</emphasis>
	functional rendering this document not very useful when it comes to the
	details.
      </para>
    </note>
    -->
    </chapter>

    <chapter id="id_preface_inside">
      <title>What's Inside</title>
      <para>
	This document is subdivided into the following chapters:
      </para>
      <formalpara>
	<title>Introduction</title>
	<para>
	  A brief explanation of the intention and nature of this document.
	</para>
      </formalpara>
      <formalpara>
	<title>&prog_t; - The Big Picture</title>
	<para>
	  This is a short depiction of the &prog; installer and the &prog;
	  environment as such. The architectural peculiarities of &prog; are
	  explained as far as it is necessary to understand the elucidations
	  that follow thereafter. 
	</para>
      </formalpara>
      <formalpara>
	<title>The &prog_t; Language - &lg_t;</title>
	<para>
	  This chapter is dedicated to the &prog; language that constitutes
	  most of the high-level functionality of &prog;. Sections covering
	  the basic language elements are accompanied by others that deal with
	  user interface creation and program structure.
	</para>
      </formalpara>
      <formalpara>
	<title>SCR Details</title>
	<para>
	  In this chapter the &prog; <emphasis>System Configuration
	    Repository</emphasis> (SCR) is explained in some concise detail. It
	  shows how to access configuration data and hardware data from within
	  &prog; modules in a consistent way.
	</para>
      </formalpara>
      <formalpara>
	<title>&prog_t; Modules</title>
	<para>
	  Some explanations regarding the different types of
	  &prog; <emphasis>modules</emphasis> as well as some rules for writing
	  them.
	</para>
      </formalpara>
      <formalpara>
	<title>Appendix A. References</title>
	<para>
	  Throughout this document there are numerous references to the &prog;
	  developers documentation. To ease access to these links this appendix
	  is mostly a dense index of those references.
	</para>
      </formalpara>
    </chapter>

    <chapter id="id_preface_style">
      <title>Style Conventions</title>
      <para>
	Throughout this document some conventions regarding the typeface of
	printed text are used:
      </para>
      <itemizedlist>
	<listitem>
	  <para>
	    <emphasis>Emphasized</emphasis> text is used to denote important
	    parts of the text.
	  </para>	   
	</listitem>
	<listitem>
	  <para>
	    Product names, file names and paths are printed using
	    <literal>literal</literal> typeface. Furthermore cut-outs from
	    programs that are embedded in the normal text flow are printed this
	    way.
	  </para>
	</listitem>
	<listitem>
	  <para>
	    Commands and command lines are printed using the
	    <command>command</command> typeface.
	  </para>
	</listitem>
	<listitem>
	  <para>
	    Keyboard keys are denoted as in <keycap>CTRL-C</keycap>.
	  </para>
	</listitem>
	<listitem>
	  <para>
	    The description of programming language elements is displayed as
	    shown below.
	  </para>
	  <para>
	    Synopsis: <command>while
	      (</command><emphasis>condition</emphasis><command>)</command>
	    <emphasis>loop_body</emphasis>
	  </para>
	  <para>
	    The parts of the language construct are printed like
	    <command>commands</command> while any arguments are printed
	    <emphasis>emphasized</emphasis>.
	  </para>
	</listitem>
      </itemizedlist>
    </chapter>

   <chapter id="introducing_yast">
    <title>Introducing &prog_t;</title>
    <para>
      &prog; is the installation program used by &lx; to install Linux on a
      system and to administer this installed system thereafter. The notation
      <quote>program</quote> is a bit misleading here because in fact &prog;
      consists of many components and layers. Therefore one may as well regard
      &prog; as an installation and administering environment.
    </para>
    <para>
      Among the most important components in this environment are the
      &prog;-modules which are usually written in a &prog;-specific language
      called <emphasis>&prog_t; Control Language</emphasis> (&lg;). With
      exception of some rare cases the whole high-level functionality of &prog;
      is formulated in &lg;. When &prog; is running, the &lg;-modules are
      interpreted by the low-level &prog;-components and the &lg;-code makes
      use of the infrastructure provided by them. The possibility to add such
      modules at any time realizes the concept of extensibility that is
      inherent in &prog;.
    </para>
    <para>
      This concept of extensibility by means of modules has been designed into
      &prog; from the very beginning. In fact &prog;-modules are the layer of
      &prog; the user comes in contact with. Nearly every dialog on screen
      during the installation is realized as a &prog;-module and there are also
      modules that act behind the scenes to care of specific pieces of
      hardware, e.g. the keyboard.
    </para>
    <para>
      The &prog;-modules mentioned so far come ready-made with the distribution
      and provide the core functionality to install and administer a
      &lx;-system, but this need not and should not be the end. The extension
      facility is intended to be also used by <quote>third party
	people</quote>, e.g. hardware vendors, who want to contribute
      &prog;-functionality in some way.
    </para>
    <para>
      To pave the way for this intention to come alive this document will
      provide some insight into the inner mechanics of &prog;. The primary goal
      of the following elucidations is to make available the information that
      is needed to write &prog;-modules that conform to the programming
      paradigm imposed by &prog;. 
    </para>

     <formalpara>
      <title>What This Document Is</title>
      <para>
	This document explains in some detail how to extend the functionality
	of &prog; by means of modules. Of course every module of more than
	trivial functionality will have to make use of the features that are
	provided by the &prog;-core-components and other &prog;-modules. While
	the official &prog; developers documentation is the primary knowledge
	base for all &prog; related information, it is a bit overwhelming for
	everyone who tries to get into the matter for the first time. Therefore
	this document tries to provide a gentle introduction by explaining
	things rather explicitly in the beginning and getting more and more
	concise towards the end. By providing very many references to the
	developers documentation this document can be thought of as a
	<quote>guided index</quote> to this voluminous material. 
      </para>
    </formalpara>

    <formalpara>
      <title>What This Document Is Not</title>
      <para>
	This document will not explain the <quote>binary</quote>
	particularities related to &prog;, i.e. there will be no implementation
	notes on how the low-level machinery of &prog; is realized. Because
	&prog; implies the module concept for extensibility, only this approach
	is promoted here. The <quote>engine</quote> that executes these modules
	and how it is assembled is subject to the following explanations only
	in so far as it is necessary to understand the interaction of the
	various components. 
      </para>
    </formalpara>
    
    <formalpara>
      <title>The Audience Of This Document</title>
      <para>
	So this document is intended for all people who want to make use of the
	&prog;-functionality by providing modules for a specific task.
	Additionally the information presented herein might be interesting for
	all those who want to adept something about the whys and wherefores
	related to &prog; as such. Furthermore, to get most out of this
	reading, the reader is supposed to have some programming experience in
	a structured programming language, ideally C/C++. Some expertise in
	functional programming could also be helpful but is not really
	necessary.
      </para>
    </formalpara>
   </chapter>

  </book>

<!-- ====== Allow emacs psgml to parse the document hierarchy ====== -->
<!-- ATTENTION * This MUST be at the end of the document * ATTENTION -->
<!--
Local Variables:
sgml-parent-document: ("preface.xml")
End:
-->
<!-- ====== Allow emacs psgml to parse the document hierarchy ====== -->

